---
title: "Glucose/Lactose experiments in the mother machine"
author: Thomas Julou
output: html_document
---

```{r variables, include=FALSE}
dt <- 3             # frame intervall (min)
dh <- 0.065         # pixel size (µm)
vertical_cutoff <- 4 / dh   # after it touched this coordinate a cell is discarded

proj_path <- "~/Documents/Biozentrum/Projects/MoM_Switch"
scripts_path <- "~/Documents/Biozentrum/Projects/vngWetLabR/mother_machine"
data2preproc <- function(.d) sub('/data/', '/preproc/', .d) # store cache file in preproc subdir

date_cond <- c("20150616"="glucose", "20150617"="glucose", "20150630"="lactose", "20150703"="switch", "20150708"="switch")
```


```{r settings}
# 
library(knitr)
opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE) # , include=FALSE

# set working environment
invisible(sapply(
  list.files(scripts_path, pattern="\\.[Rr]$", full.names=TRUE, ignore.case=TRUE), 
  source, .GlobalEnv))
setwd(proj_path)

library(parallel)
numCores <- min(16, detectCores()) # do not use more than 16 cores
```


```{r load_mg_data}
mg_files <- list.files("./data/MG1655_glu_lac", ".*\\d+\\.csv", recursive=TRUE, full.names=TRUE)

# load perl scripts output to dataframes (using parallel lapply)
# NB: creating a list of dataframes and rbind them at last is faster than using rbind in a loop
l_data <- mclapply(mg_files, 
                function(.f) try( load_timm_data(.f, scripts_path, .verbose=TRUE, .data2preproc=data2preproc)), #, .force=TRUE
                mc.cores=numCores)

mg_cells <- l_data %>% 
  lapply(function(.l) .l$cells) %>% 
  do.call(rbind, .) %>%
  mutate(cell=paste(date, pos, gl, id, sep='.'))

mg_frames <- l_data %>% 
  lapply(function(.l) .l$frames) %>% 
  do.call(rbind, .) %>%
  # remove frames after touching the exit
  group_by(date, pos, gl, id) %>%
  mutate(discard_top=which_touch_exit(vertical_top, vertical_cutoff)) %>%
  # remove daughters of cells that touched the exit
  ungroup %>% group_by(date, pos, gl) %>%
  mutate(discard_top=which_to_progeny(discard_top, cid)) %>%
  mutate(b_rank=mean(total_cell_in_lane - cell_num_in_lane)) %>%
  #   filter(discard_top==FALSE) %>%
  mutate(frame=time_sec / dt / 60,
         vertical_center=(vertical_bottom + vertical_top)/2,
         cell=paste(date, pos, gl, id, sep='.'))

```

```{r load_ASC662_data}
switch_ts <- data.frame(t_start=c(0, 360, 600, 840, 1080, 1320), 
                        t_end=c(360, 600, 840, 1080, 1320, 1560), 
                        cond=c('glucose', 'lactose', 'glucose', 'lactose', 'glucose', 'lactose'))
glc_files <- list.files("./data/glucose", ".*\\d+\\.csv", recursive=TRUE, full.names=TRUE)
lac_files <- list.files("./data/lactose", ".*\\d+\\.csv", recursive=TRUE, full.names=TRUE)
swi_files <- list.files("./data/glu_lac_switch", ".*\\d+\\.csv", recursive=TRUE, full.names=TRUE)
# swi_files_all <- swi_files
# swi_files <- swi_files[1]

# load perl scripts output to dataframes (using parallel lapply)
# NB: creating a list of dataframes and rbind them at last is faster than using rbind in a loop
l_data <- mclapply(c(glc_files, lac_files, swi_files), 
                function(.f) try( load_timm_data(.f, scripts_path, .verbose=TRUE, .data2preproc=data2preproc)), #, .force=TRUE
                mc.cores=numCores)

mycells <- l_data %>% 
  lapply(function(.l) if('cells' %in% names(.l)) .l$cells) %>% 
  do.call(rbind, .) %>%
  mutate(condition=date_cond[as.character(date)]) %>%
  mutate(discard_start= (start_time < 2*3600) )

myframes <- l_data %>% 
  mclapply(function(.l) {
    if ('frames' %in% names(.l)) {
      .l$frames %>%
        # remove frames after touching the exit
        group_by(id) %>%
        mutate(discard_top=which_touch_exit(vertical_top, vertical_cutoff)) %>%
        # remove daughters of cells that touched the exit
        ungroup %>%
        mutate(discard_top=which_to_progeny(discard_top, cid))
      }
    }) %>% 
  do.call(rbind, .) %>%
  mutate(condition=date_cond[as.character(date)],
         discard_start=(time_sec < 2*3600) ) %>%
  mutate(b_rank=mean(total_cell_in_lane - cell_num_in_lane)) %>%
  #   filter(discard_top==FALSE) %>%
  mutate(frame=time_sec / dt / 60,
         vertical_center=(vertical_bottom + vertical_top)/2,
         cell=paste(date, pos, gl, id, sep='.'))


```



```{r}
ggplot(data=filter(mg_frames, !discard_top, pos==0,  gl==14), aes(group=interaction(date, pos, gl, id))) + 
#   geom_rect(aes(xmin=t_start, xmax=t_end, ymin=-Inf, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), data=filter(switch_ts, cond=='lactose')) +
  geom_rect(aes(xmin=dt*(frame-.5), xmax=dt*(frame+.5), ymin=-(dh*vertical_center-height_micrometer/2), ymax=-(dh*vertical_center+height_micrometer/2), fill=fluo_amplitude/height_micrometer)) +
  geom_path(aes(dt*frame, -dh*vertical_center)) +
#   geom_rect(aes(xmin=t_start, xmax=t_end, ymin=-Inf, ymax=Inf, group=1), col='red', fill="transparent", data=filter(switch_ts, cond=='lactose')) +
  labs(x="time (min)", y="position (µm)", "GFP concentration")
```


# Curation stats


```{r load_timm_data}
timm_files <- list.files("./data", "^\\d+_pos[^/]*\\.timm$", recursive=TRUE, full.names=TRUE)

l_data <- lapply(timm_files, function(.f) try(parse_timm_curation(.f) %>%
                                                data.frame(path=.f, .)) )
timm_data <- lapply(l_data, function(.df) {
  if (class(.df) == 'try-error') return(data.frame())
  # keep only the first line of a frame for each SSCxAction events
  # combine it (using rbind) with all other events
  rbind(.df %>% 
          filter(type=='SSC') %>%
          group_by(frame, action) %>%
          summarise_each(funs(first)) %>%
          ungroup %>% 
          select(path, type, frame, action),
        filter(.df, type!='SSC') %>%
          select(path, type, frame, action) ) %>%
    arrange(type, frame)
  }) %>%
  do.call(rbind, .) %>%
  extract(path, c('date', 'pos', 'gl'), ".*/(\\d+)_pos(\\d+)_[^/]*GL0*(\\d+)\\.timm") %>%
  mutate(date=as.numeric(date), pos=as.numeric(pos), gl=as.numeric(gl))


mygl <- myframes %>%
  # start from the total number of observations
  group_by(date, pos, gl) %>%
  summarise(n_obs=n()) %>%
  # add the number of dividing cells
  left_join(select(mycells, date, pos, gl, id, parent_id, end_type, condition) %>%
                         filter(end_type=='div', parent_id>=0) %>%
                         group_by(condition, date, pos, gl) %>%
                         summarise(n_div_cells=n()) ) %>%
  # add curation times
  left_join(read.csv("./data/curation_times.csv") %>%
              na.omit %>%
              mutate(pos=as.numeric(gsub('pos', '', pos)),
                     gl=as.numeric(gsub('GL', '', gl))) ) %>%
  # add the number of curated frames
  left_join(rbind(
    timm_data %>% 
      filter(type != 'none') %>%
      group_by(date, pos, gl) %>%
      summarise(nframes=length(unique(frame))),
    timm_data %>% 
      filter(type == 'none') %>%
      group_by(date, pos, gl) %>%
      summarise(nframes=0)) )


kable(mygl %>%
  group_by(condition) %>%
  summarise(n_lanes=length(unique(interaction(date, pos, gl))),
            n_div_cells=sum(n_div_cells),
            n_obs=sum(n_obs),
            time_avg=mean(time, na.rm=TRUE),
            time_sd=sd(time, na.rm=TRUE) ))

```


```{r}
qplot(time, data=mygl, xlab='curation time (min)')

ggplot(data=mygl, aes(nframes, time)) +
  geom_smooth(method='lm', se=FALSE) +
  geom_point(position=position_jitter(width=.1)) +
  # geom_rug(sides='r', position=position_jitter(), size=5, alpha=.2) +
  ylim(0, 20) +
  labs(x='number of curated frames', y='curation time (min)')
ggsave('plots/curation_times_frames.pdf', width=4, height=3)

ggplot(data=filter(mygl, n_div_cells>40), aes(n_div_cells, time)) +
  geom_point(position=position_jitter(width=.1)) +
  geom_point(data=filter(mygl, n_div_cells>40) %>% ungroup %>% select(n_div_cells, time) %>% mutate_each(funs(as.numeric)) %>% summarise_each(funs(median(., na.rm=T))), col='red', pch='+', size=10) +
  # geom_rug(sides='r', position=position_jitter(), size=5, alpha=.2) +
  ylim(0, 20) +
  labs(x='number of entire cell cycles', y='curation time (min)')
ggsave('plots/curation_times_divcells.pdf', width=4, height=3)

```


# Fluorescence estimation

## Autofluorescence estimation

Let's look at how autofluorescence (measured as the fluorescence of MG1655 cells without GFP) correlates with cell length.

```{r autofluo}
ggplot(data=filter(mg_frames, !discard_top)) + 
  geom_point(aes(height_micrometer, fluo_amplitude), size=1, alpha=.2, position=position_jitter(width=1e-2)) + 
  geom_smooth(aes(height_micrometer, fluo_amplitude, col='y=ax'), method='lm', formula=y~x-1,
              data=filter(mg_frames, !discard_top, height_micrometer>1.7, height_micrometer<3.4)) +
  # xlim(0,6) + ylim(0, 3000)

ggplot(data=filter(mg_frames, !discard_top), aes(height_micrometer, fluo_amplitude)) + 
  geom_point(size=1, alpha=.2, position=position_jitter(width=1e-2)) + 
  geom_smooth(method='lm', col='red', formula=y~x-1, fullrange=TRUE,
              data=filter(mg_frames, !discard_top, height_micrometer>1.7, height_micrometer<3.4))+
  labs(x='cell length (µm)', y='total fluorescence (AU)') +
  xlim(0,6) + ylim(0, 3000)
ggsave('plots/mg_autofluo_length.pdf', width=5, height=3)

```

Let's check visually that fluctuations for a given cell correlate with its length (rather than having some cells systematically high or low). Then, we look at cells with high autofluorescence values: we checked manually for some of these that they exhibit a hot pixel (contributing the size-independent "autofluorescence").

```{r}
# sample cell trace
ns <- 6
ggplot(data=filter(mg_frames, !discard_top, pos==0,  gl==14) %>% 
         filter(cell %in% unique(cell)[sample(1:40, ns)])) + 
  geom_path(aes(height_micrometer, fluo_amplitude, col=cell), alpha=.5) + 
  geom_abline(slope=mean_autofluo$slope0) +
  xlim(1,4) + ylim(0, 3000)


autofl_outliers_cell <- filter(mg_frames, !discard_top, fluo_amplitude>2500, height_micrometer<4) %>%
  ungroup %>% .[['cell']] %>% unique
ggplot(data=filter(mg_frames, !discard_top, cell %in% autofl_outliers_cell)) + 
  geom_path(aes(height_micrometer, fluo_amplitude, col=cell), alpha=.5) + 
  geom_abline(slope=mean_autofluo$slope0) +
  xlim(1,4) + ylim(0, 3000)

```


We estimate the slope of each cell that is not filamenting (between 1.7 and 3.4µm) and that is observed over 5 frames or more.
These slopes display a strong negative correlation with the intercepts. Cells with non-zero intercepts might correspond to cells with hot/dead pixels. Overall, the default intercept is not zero (does this correspond to the sum of non-zero values of pixels in the dark?).

```{r}
nframes_autofluo <- 5
mg_autofluo <- filter(mg_frames, !discard_top, height_micrometer>1.7, height_micrometer<3.4) %>%
  group_by(date, pos, gl, id) %>%
  mutate(npoints=n()) %>% filter(npoints>=nframes_autofluo) %>%
  do(mod0=lm(fluo_amplitude~height_micrometer-1, data=.), mod=lm(fluo_amplitude~height_micrometer, data=.)) %>%
  mutate(intercept=coef(mod)[1], slope=coef(mod)[2], slope.sd=summary(mod)$coeff[2, 2], 
         slope0=coef(mod0)[1], slope0.sd=summary(mod0)$coeff[1, 2],
         r2=summary(mod)$r.squared, r2_0=summary(mod0)$r.squared)

ggplot(mg_autofluo, aes(intercept, slope)) +
  geom_errorbar(aes(ymin=slope-slope.sd, ymax=slope+slope.sd), alpha=0.2) +
  geom_point(alpha=0.2) +
  geom_vline(xintercept=c(-500, 900), col='red')

qplot(intercept, data=mg_autofluo) +
  geom_vline(xintercept=c(-500, 900), col='red')

```

Overall the fit is much better for a model constrained through the origin?! This yields a narrower distribution of slopes. We use this model and estimate the average slope (using errors) to predict the autofluorescence at a given cell length.

```{r}
ggplot(filter(mg_autofluo, between(intercept, -500, 900))) +
  stat_ecdf(aes(r2_0, col='Y=aX')) +
  stat_ecdf(aes(r2, col='Y=aX+b')) +
  labs(x='r2', y='cumulative', col='model')

mean_autofluo <- mg_autofluo %>% ungroup %>%
  summarise(slope0=sqrt( sum(slope0^2/slope0.sd^2) / sum(1/slope0.sd^2) ), 
            slope0.sd=1 / sqrt(sum(1/slope0.sd^2)))

ggplot(filter(mg_autofluo, between(intercept, -500, 900))) +
  geom_stephist(aes(slope0, col='Y=aX')) +
  geom_stephist(aes(slope, col='Y=aX+b')) +
  geom_vline(aes(xintercept=slope0, col='Y=aX'), data=mean_autofluo, lty='dashed') +
  labs(x='slope (DN/µm)', col='model')

autofluo_predict <- function(.h) .h * mean_autofluo$slope0
myframes <- myframes %>%
    mutate(fluogfp_amplitude = fluo_amplitude - autofluo_predict(height_micrometer))

```


The autofluorescence concentration is noticeably impacted by the extracellular conditions. For instance, it increases dramatically when the environment is switched to lactose. Are the intial and post-switch decreases due to bleaching?

```{r}
ggplot(data=filter(mg_frames, !discard_top) %>% head(1e4), aes(time_sec, fluo_amplitude/height_micrometer)) + 
  geom_rect(aes(x=1, y=1, xmin=12*3600, xmax=24*3600, ymin=-Inf, ymax=Inf, fill='lactose'), alpha=.1, data=data.frame()) + # draws one rectangle per data line
  geom_hline(yintercept=mean_autofluo$slope0, lty='dashed') +
  geom_point(alpha=.2, size=1) +
  geom_smooth(method='loess', span=.05, se=FALSE) +
  scale_x_hours() +
  ylim(0, 1e3) +
  labs(x='time (h)', y='autofluorescence \nconcentration (DN/µm)', fill='condition')
ggsave('plots/mg_autofluoconc_time.pdf', width=6, height=3)

```



## Photobleaching estimation

### Rationale
We assume that fluorescent proteins (FPs) are present in two states: unbleached (U) and bleached (B). FPs are produced as unbleached at a rate $\alpha$. Unbleached proteins are bleached at a rate $\beta$ and all proteins are degraded at a rate $\delta$. The total fluorescence measured in a cell is proportional to U. \
NB: the assumption that the probablity of degradation is constant with time is not realistic, contrary to the assumption of a constant rate of bleaching. \
![bleaching process](material/bleachingProcess.png)

When FPs are produced (lactose): $\frac{dU}{dt} = \alpha - (\beta + \delta) U$ \
When no FPs are produced (glucose): $\frac{dU}{dt} = -(\beta + \delta) U$ \

When no FPs are produced, the total fluorescence decreases rapidly (though the total number of FPs is expected to be constant). This is a direct observation of photobleaching and protein degradation and we can estimate $\beta + \delta$ as the decay rate of U. We also use this regime to estimate the conversion factor between camera units and FP units. In this case, the partitioning can be better estimated by extrapolating the mother and daughters fluorescence at division between the 2 adjacent time points (based on the exponential decay model).

When FPs are produced, $U(t+dt) = U(t) - (\beta + \delta) dt U(t) + \alpha(t) dt (\beta + \delta) dt$. \
$\alpha = (U(t+dt) - U(t) + (\beta + \delta) dt U(t)) / (\beta + \delta) dt^2$
Hence knowing the bleaching and degradation rate, one can estimate the instantaneous production rate \alpha(t)
NB: means that average production rate over the cell cycle not taking bleaching and degradation into account are correct up to a constant.


### Estimation

We focus on estimating $\beta + \delta$ and aim at extrapolating the mother and daughters fluorescence at division between the 2 adjacent time points.

Let's first look at fluorescence decay for cells in a given lane. The slopes are steeper for more fluorescent cells, which suggests proportional decay (as expected). This is nicely confirmed by constant slope in log scale.

```{r}
ggplot(data = filter(myframes, !discard_start, !discard_top, condition=='switch', end_type=='div', time_sec>(2+4)*3600, 
                     between_or(time_sec, 
                                (filter(switch_ts, cond=='glucose')$t_start+30)*60, 
                                (filter(switch_ts, cond=='glucose')$t_end-30)*60) ) %>% 
         mutate(glid=paste(date, pos, gl, sep='.')) %>% filter(glid %in% nth(unique(glid), 11)) %>%
         group_by(date, pos, gl, id) %>% 
         mutate(time_sec_ini=first(time_sec)), 
       aes(time_sec - time_sec_ini, fluogfp_amplitude, col=cell)) +
  geom_path(alpha=0.6) +
  expand_limits(y=0) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours(0.5)
  
last_plot() +
  scale_y_log10()

bleaching_fits <- filter(myframes, !discard_start, !discard_top, condition=='switch', 
                         fluogfp_amplitude > autofluo_predict(height_micrometer),
                         time_sec>(2+4)*3600, # end_type=='div',
                         between_or(time_sec, 
                                    (filter(switch_ts, cond=='glucose')$t_start+30)*60, 
                                    (filter(switch_ts, cond=='glucose')$t_end-30)*60) ) %>% 
  group_by(date, pos, gl, id) %>% 
  mutate(npoints=sum(fluogfp_amplitude>0)) %>%
  filter(npoints>10) %>%
  do(npoints=first(.$npoints), time_sec_ini=first(.$time_sec), fluogfp_amplitude_ini=first(.$fluogfp_amplitude),
     mod_lin=lm(fluogfp_amplitude~time_sec, data=.), mod_exp=lm(log(fluogfp_amplitude)~time_sec, data=.)) %>%
  mutate(npoints=unlist(npoints), time_sec_ini=unlist(time_sec_ini),
         fluogfp_amplitude_ini=unlist(fluogfp_amplitude_ini),
         slope=summary(mod_lin)$coeff[2], r2=summary(mod_lin)$r.squared,
         exp_slope=summary(mod_exp)$coeff[2], exp_r2=summary(mod_exp)$r.squared,
         exp_slope.sd=summary(mod_exp)$coeff[2, 2]) %>%
  mutate(cell=paste(date, pos, gl, id, sep='.'))

```

We fit the decay (accounting for the cell autofluorescence) for each cell observed on 10 frames or more and with GFP fluorescence greater than the predicted autofluorescence. Surprinsingly, exponential fits do not have higher r2 than linear fits. However, the distribution of slopes is narrower with the exponential model.

```{r}
ggplot(data = bleaching_fits) +
  stat_ecdf(aes(r2, col='lin')) +
  stat_ecdf(aes(exp_r2, col='exp')) +
  labs(col='model', y='cumulative')

.bw <- .1
ggplot(data = filter(bleaching_fits, r2>.8)) +
  geom_stephist(aes(slope/mean(slope), col='lin'), binwidth=.bw) +
  geom_stephist(aes(exp_slope/mean(exp_slope, na.rm=T), col='exp'), binwidth=.bw)

```

This can be explained by the fact that each cell spans a relatively narrow range of fluorescence (where linear and exponential decay are comparable) during its cell cycle. Hence the quality of the fit is dominated by experimental errors rather than by the overall shape. Moreover the broader distribution of slopes with the linear model can be explained by the fact that the slope scales with the total fluorescence in the linear model while the decay rate doesn't.

```{r}
qplot(fluogfp_amplitude_ini, slope, data=bleaching_fits) + 
  geom_smooth(method='lm')
qplot(fluogfp_amplitude_ini, exp_slope, data=bleaching_fits) +
  geom_smooth(method='lm')

```

We compute the average decay by taking the slope errors into account:

```{r}
bleaching_rate <- bleaching_fits %>%
  ungroup %>%
  summarise(mean=-sqrt( sum(exp_slope^2/exp_slope.sd^2) / sum(1/exp_slope.sd^2) ), 
            sd=1 / sqrt(sum(1/exp_slope.sd^2)))

ggplot(data = bleaching_fits) +
  geom_histogram(aes(exp_slope), fill='gray35') +
  geom_vline(xintercept=bleaching_rate$mean) +
  labs(x='bleaching + decay rate (/s)')


bleaching_predict <- function(.h) .h * mean_autofluo$slope0
```



## GFP conversion factor estimation

For each division event (where mother and both daughters are observed for 10 frames or more; discarding bottom cell), we estimate the fluorescence and size at division. On one hand, we do it by average ing the last and first 3 frames around division; on the other hand, we do it by fitting the previously characterized exponential decay for the fluorescence and a free exponential growth for the size to the last and first 10 frames around division.

Reassuringly, while the daughters sum is systematically lower than their mother (due to bleaching + degradation) with the average estimation, the sum is closer to the mother value with the fit. In the following we assume these are equal and use the sum to compute the bias since this is less subject to measurement errors. Regarding the size estimation, the fit underestimate size at birth as already established by Erik.

```{r}

ggplot(data = filter(myframes, !discard_start, !discard_top, condition=='switch', 
                     cell_num_in_lane < total_cell_in_lane,
                     time_sec>(2+4)*3600, 
                     between_or(time_sec, 
                                (filter(switch_ts, cond=='glucose')$t_start+30)*60, 
                                (filter(switch_ts, cond=='glucose')$t_end-30)*60)) %>% 
         mutate(glid=paste(date, pos, gl, sep='.')) %>% filter(glid %in% nth(unique(glid), 11)) %>%
         group_by(date, pos, gl, id) %>% 
         mutate(npoints=sum(gfp_amplitude>0)) %>%
         filter(npoints>10) %>%
         mutate(time_sec_ini=first(time_sec), gfp_amplitude_ini=first(gfp_amplitude)), 
       aes(time_sec, gfp_amplitude, col=cell)) +
  geom_path(alpha=0.6) +
  expand_limits(y=0) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours(2) 


triad_avgw <- 3
triad_fitw <- 10
swi_triads <- filter(myframes, !discard_start, !discard_top, condition=='switch', 
                     cell_num_in_lane < total_cell_in_lane,
                     time_sec>(2+4)*3600, 
                     between_or(time_sec, 
                                (filter(switch_ts, cond=='glucose')$t_start+30)*60, 
                                (filter(switch_ts, cond=='glucose')$t_end-30)*60)) %>%
  group_by(date, pos, gl) %>%
  do( (function(.df1){
    # first loop on all growth lanes
    filter(.df1, end_type=="div") %>%
      group_by(id) %>%
       do( (function(.df1, .dfp){
          # then loop on all cells
         if (sum(.dfp$fluogfp_amplitude>0) < max(triad_avgw, triad_fitw)) return(data.frame())
         .dfcb <- filter(.df1, parent_id==unique(.dfp$id), daughter_type=='BOTTOM')
         if (sum(.dfcb$fluogfp_amplitude>0) < max(triad_avgw, triad_fitw)) return(data.frame())
         .dfct <- filter(.df1, parent_id==unique(.dfp$id), daughter_type=='TOP')
         if (sum(.dfct$fluogfp_amplitude>0) < max(triad_avgw, triad_fitw)) return(data.frame())
         # browser()
  
         fluo_intercept_p <- coef(lm(I( log(fluogfp_amplitude) - bleaching_rate$mean * time_sec ) ~ 1, data=.dfp))
         fluo_intercept_cb <- coef(lm(I( log(fluogfp_amplitude) - bleaching_rate$mean * time_sec ) ~ 1, data=.dfcb))
         fluo_intercept_ct <- coef(lm(I( log(fluogfp_amplitude) - bleaching_rate$mean * time_sec ) ~ 1, data=.dfct))
         height_modp <- lm(log(height_micrometer)~time_sec, data=.dfp) %>% coef
         height_modcb <- lm(log(height_micrometer)~time_sec, data=.dfcb) %>% coef
         height_modct <- lm(log(height_micrometer)~time_sec, data=.dfct) %>% coef

         bind_cols(
           filter(.dfp, row_number() > dim(.dfp)[1] - triad_avgw) %>%
             select(end_time, height_avg=height_micrometer, fluo_avg=fluogfp_amplitude) %>%
             summarise_each(funs(mean)) %>%
             bind_cols(data.frame(div_time=unique(.dfp$end_time)+dt/2*60) %>% 
                         mutate(fluo_fit = exp(fluo_intercept_p + div_time * bleaching_rate$mean),
                                height_fit = exp(height_modp[1] + div_time * height_modp[2]))),
           
           filter(.dfcb, row_number() <= triad_avgw) %>%
             select(id, height_avg=height_micrometer, fluo_avg=fluogfp_amplitude) %>%
             summarise_each(funs(mean)) %>%
             bind_cols(data.frame(div_time=unique(.dfp$end_time)+dt/2*60) %>% 
                         mutate(fluo_fit = exp(fluo_intercept_cb + div_time * bleaching_rate$mean),
                                height_fit = exp(height_modcb[1] + div_time * height_modcb[2])) %>%
                         select(-div_time)) %>%
             setNames(., paste("b", names(.), sep=".")),
           
           filter(.dfct, row_number() <= triad_avgw) %>%
             select(id, height_avg=height_micrometer, fluo_avg=fluogfp_amplitude) %>%
             summarise_each(funs(mean)) %>%
             bind_cols(data.frame(div_time=unique(.dfp$end_time)+dt/2*60) %>% 
                         mutate(fluo_fit = exp(fluo_intercept_ct + div_time * bleaching_rate$mean),
                                height_fit = exp(height_modct[1] + div_time * height_modct[2])) %>%
                         select(-div_time)) %>%
             setNames(., paste("t", names(.), sep="."))
         )
       })(.df1, .) )
  })(.) )


ggplot(swi_triads) +
  geom_point(aes(fluo_avg, b.fluo_avg+t.fluo_avg, col='avg'), alpha=.5) +
  geom_point(aes(fluo_fit, b.fluo_fit+t.fluo_fit, col='fit'), alpha=.5) + 
  geom_abline() +
  labs(col='estimation')

ggplot(swi_triads) +
  geom_point(aes(height_avg, b.height_avg+t.height_avg, col='avg'), alpha=.5) +
  geom_point(aes(height_fit, b.height_fit+t.height_fit, col='fit'), alpha=.5) + 
  geom_abline() +
  labs(col='estimation')

```


```{r}
qplot(b.fluo_fit+t.fluo_fit, b.fluo_fit / (b.fluo_fit + t.fluo_fit), data=swi_triads, geom="blank") +
  geom_hline(yintercept=0.5, lty='dashed') + 
  stat_density2d(fill='blue', col='transparent', alpha=.05, geom='polygon', binwidth=1e-4) +
  geom_point(alpha=0.5, size=1) + 
  # ylim(0, 1) +
#   geom_pointrange(aes(x=fluo, y=m, ymin=m-s, ymax=m+s), 
#                   data=data.frame(fluo=seq(5e3, 4e4, 1e3)) %>% mutate(
#                     m=sapply(fluo, function(.fl) 
#                       filter(swi_triads, between(fluo_fit, .fl-1e3, .fl+1e3)) %>% mutate(bias=b.fluo_fit / (b.fluo_fit + t.fluo_fit)) %>% .[['bias']] %>% mean),
#                     s=sapply(fluo, function(.fl) 
#                       filter(swi_triads, between(fluo_fit, .fl-1e3, .fl+1e3)) %>% mutate(bias=b.fluo_fit / (b.fluo_fit + t.fluo_fit)) %>% .[['bias']] %>% sd)) ) +
  labs(x='total fluorescence (DN)', y='fluorescence bias toward bottom daughter') 
ggsave('plots/asc_nutriads_fluotot.pdf', width=4, height=3)

qplot(b.height_avg / (b.height_avg + t.height_avg) , b.fluo_fit / (b.fluo_fit + t.fluo_fit), data=swi_triads, geom="blank") +
  geom_abline() +
  geom_smooth(method='lm', se=FALSE) + 
  geom_point(alpha=0.2) + 
  # ylim(0.4, 0.6) +
  labs(x='size bias toward bottom daughter', y='fluorescence bias toward bottom daughter') 
ggsave('plots/asc_nutriads_size.pdf', width=4, height=3)

mod <- lm(I(b.fluo_fit / (b.fluo_fit + t.fluo_fit)) ~ I(b.height_avg / (b.height_avg + t.height_avg)), data=swi_triads)
summary(mod)$r.squared

```

For each triad, we can compute a conversion factor (cf Rosenfeld method 1).

```{r}
swi_triads <- swi_triads %>%
  mutate(nu=(b.fluo_fit - t.fluo_fit)^2 / ((b.fluo_fit + t.fluo_fit)),
         fluo_bin=cut2(fluo_fit, cuts=seq(0, 1e5, 5e3), oneval=FALSE)) # fluo_bin2=Hmisc::cut2(fluo_fit, g=7, oneval=FALSE)
nu_star <- mean(swi_triads$nu, na.rm=TRUE) # DN per FP
nu_err <- nu_star / sqrt(dim(swi_triads)[1])

```

or use Erik's method accounting for fluctuations in size.

```{r}
# write.csv(swi_triads %>% data.frame, file='nu_triads_bleachcorrected.csv')

partitioning_loglik <- function(.lambda, .v, .x, .y) {
  if (length(.x) != length(.y)) stop('.x and .y must have the same length')
  .a <- .v + 1 / (4*.lambda * (.x+.y))
  sum( - (.x/(.x+.y) -.5)^2 / .a - log(.a), na.rm=TRUE)
}
partitioning_loglik_wrapper <- function(.pars, .x, .y)
  partitioning_loglik(.pars[1], .pars[2], .x, .y)

partitioning_opt <- optim(c(.1, 1e-4), partitioning_loglik_wrapper, .x=swi_triads$b.fluo_fit, .y=swi_triads$t.fluo_fit,
      control = list(fnscale = -1))
if (partitioning_opt$convergence == 0) { fp_per_dn <- partitioning_opt$par[1]} else { rm('fp_per_dn') }

```

This yields a conversion factor FP/DN at `r format(fp_per_dn, digits=2)`. The sd of the volume bias is infered to be `r sqrt(partitioning_opt$par[2]) %>% format(digits=2)` while it is measured at `r (swi_triads$b.height_fit / (swi_triads$b.height_fit+swi_triads$t.height_fit)) %>% sd %>% format(digits=2)`.


We can now look at how the fluorescence measurement convert to number of gfp molecules.

```{r}

myframes <- myframes %>%
  # convert to gfp units (after subtracting autofluorescence)
  mutate(., gfp_nb = fluogfp_amplitude * fp_per_dn)

ggplot(data=myframes %>% filter(condition=='glucose') %>% head(1e5),
       aes(fluo_amplitude, gfp_nb)) +
  geom_point(alpha=0.1) 

ggplot(data=myframes %>% filter(condition=='lactose', height_micrometer<3) %>% head(1e5),
       aes(fluo_amplitude, gfp_nb)) +
  geom_point(alpha=0.1) 

qplot(gfp_nb, data=myframes %>% filter(condition=='lactose', height_micrometer<3), binwidth=50)
qplot(height_micrometer, gfp_nb, data=myframes %>% filter(condition=='lactose', height_micrometer<3), alpha=I(.01))
```



# Constant environments

## Growth in constant environments

```{r}
ggplot(filter(myframes, !discard_start, !discard_top, condition=='glucose', end_type=='div', start_time>=2*3600) %>% filter(cell %in% c(nth(cell, 1), nth(cell, 100), nth(cell, 30), nth(cell, 300), nth(cell, 400))),
       aes((time_sec-start_time)/60, height_micrometer, col=cell)) +
  stat_smooth(method='lm', se=FALSE) +
  geom_path(alpha=0.8, size=1) +
  scale_colour_periodic_brewer(guide='none') +
  scale_y_continuous(trans='log2', limits=c(1, 4)) +
  labs(x='time after division (min)', y='length (µm)')
ggsave('plots/asc_loglength_time.pdf', width=4, height=3)


ggplot(filter(mycells, !discard_start, condition!='switch', end_type=='div', start_time>=2*3600),
       aes(Rsize_vs_time^2, col=condition)) +
  stat_ecdf() +
  labs(x='exponential fit r2', y='cumulative probability') +
  theme(legend.position=c(0.15, 0.8)) +
  xlim(0.94, 1) 
ggsave('plots/asc_loglength_time_r2ecdf.pdf', width=4, height=3)


myr2 <- filter(myframes, !discard_start, !discard_top, condition!='switch', end_type=='div', start_time>=2*3600) %>%
  group_by(date, pos, gl, id) %>%
  do((function(.df) {
    .mod <- lm(log(height_micrometer)~time_sec, data=.df)
    return(data.frame(logh_time_slope=coef(.mod)[2], logh_time_r2=summary(.mod)$r.squared))
  })(.) )

```


```{r}

ggplot(filter(mycells, !discard_start, end_time>5*3600, condition!='switch', end_type=='div'),
       aes(end_time, (end_time-start_time)/60, col=condition)) +
  geom_point(alpha=0.2) +
  # stat_smooth(method='loess', span=.7, se=FALSE, size=1) +
  stat_smooth(method='lm', size=1) +
  scale_x_hours() +
  labs(y='division time (min)') +
  expand_limits(y=0) + 
  ylim(0, 200)
 
# table(filter(mycells, condition!='switch')$Rsize_vs_time^2>.95)
ggplot(filter(mycells, !discard_start, condition!='switch', end_type=='div'),
       aes(end_time - 2*3600, log(2)/slope_size_vs_time / 60, col=condition)) +
  geom_point(alpha=0.2, size=1,
             data=filter(mycells, Rsize_vs_time^2>.95, !discard_start, condition!='switch', end_type=='div')) +
  # stat_smooth(method='loess', span=.7, se=FALSE, size=1) +
  stat_smooth(method='lm', size=1,
              data=filter(mycells, end_time>5*3600, Rsize_vs_time^2>.95, !discard_start, condition!='switch', end_type=='div')) +
  scale_x_hours(5, name='time at division (h)') +
  labs(y='doubling time (min)') +
  expand_limits(x=0, y=0)
ggsave('plots/asc_dt_divtime.pdf', width=6, height=3)

```

Let's check that cells with long doubling time are not filamentous.

```{r}
h_end <- select(mycells, date, pos, gl, id, time_sec=end_time) %>%
         left_join(select(myframes, date, pos, gl, id, time_sec, height_micrometer))
mycells <- mutate(mycells, height_um_end = h_end$height_micrometer)


ggplot(filter(mycells, !discard_start, end_time>5*3600, condition!='switch', end_type=='div'),
       aes(height_um_end, log(2)/slope_size_vs_time / 60, col=condition)) +
  geom_point(alpha=0.2) +
  # stat_smooth(method='loess', span=.7, se=FALSE, size=1) +
  stat_smooth(method='lm', size=1) +
  labs(y='doubling time (min)') +
  ylim(0, 300)

```


```{r eval=FALSE}
ggplot(filter(mycells, !discard_start, condition!='switch', end_type=='div'), # %>% filter(Rsize_vs_time^2>.98),
       aes(log(2)/slope_size_vs_time / 60)) +
  stat_bin(aes(y=..density.., fill=condition), geom='bar', position='identity', col='transparent', alpha=.2) + 
  geom_stephist(aes(y=..density.., col=condition), position='identity') + 
    # stat_ecdf() +
  labs(x='doubling time (min)') +
  xlim(0, 300)
ggsave('plots/asc_dt.pdf', width=6, height=2)

 ggplot(filter(mycells, !discard_start, condition!='switch', end_type=='div'), # filter(Rsize_vs_time>.992)
       aes(Rsize_vs_time^2, col=condition)) +
  stat_density(geom='line') + 
  xlim(0.95, 1)

ggplot(filter(mycells, !discard_start, condition!='switch', end_type=='div'),
       aes(log(2)/slope_size_vs_time / 60, Rsize_vs_time, col=condition)) +
  geom_point(alpha=.2) + 
  geom_smooth(method='lm') +
  xlim(0, 150) + ylim(0.95, 1) +
  facet_wrap(~condition)

```


## Fluo in lactose

look for decreasing stretches in lactose + check correl with growth rate


```{r}
ggplot(filter(myframes, !discard_start, !discard_top, condition=='lactose', end_type=='div', parent_id>0) %>% head(2e3),
       aes(time_sec - 2*3600, gfp_amplitude, col=cell)) +
    geom_rect(aes(xmin=0, xmax=Inf, ymin=-Inf, ymax=Inf, x=NaN, y=NaN), fill=rgb(1, 0, 0, .1), col='transparent', data=data.frame()) +
  geom_path(alpha=0.8) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours(5) +
  labs(y='total fluorescence (GFP molecules)') +
  expand_limits(x=0, y=0)
ggsave('plots/asc_gfp_time.pdf', width=6, height=3)

ggplot(filter(mycells, !discard_start, condition=='lactose', end_type=='div', Rfluo_vs_time^2 > 0.95),
       aes(dfluo_per_sec * fp_per_dn)) +
  stat_bin() +
  labs(x='GFP production rate (/sec)')
ggsave('plots/asc_gfpprod.pdf', width=6, height=2)

```


# Switching environment

## Growth lag

```{r}
ggplot(filter(myframes, !discard_start, !discard_top, condition=='switch', end_type=='div') %>% mutate(glid=paste(date, pos, gl, sep='.')) %>% filter(glid %in% nth(unique(glid), 11)),
       aes(time_sec - 2*3600, height_micrometer, col=cell)) +
  geom_rect(aes(xmin=t_start*60 - 2*3600, xmax=t_end*60 - 2*3600, ymin=0, ymax=Inf, x=NaN, y=NaN, group=1), fill=rgb(1, 0, 0, .1), size=0.2, col='red', data=filter(switch_ts, cond=='lactose')) +
  geom_path(alpha=0.6) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours(4) +
  scale_y_continuous(trans='log2') +
  labs(y='height (µm)') +
  expand_limits(x=0, y=0)

ggsave('plots/asc_switch_length.pdf', width=8, height=3)

# xxx average before switch
# select cells that exist at switch and divide more than 50' after
# normalize by avg length around the switch


```

## Fluo induction

```{r}

ggplot(filter(myframes, !discard_start, !discard_top, condition=='switch', end_type=='div') %>% mutate(glid=paste(date, pos, gl, sep='.')) %>% filter(glid %in% nth(unique(glid), 11)),
       aes(time_sec - 2*3600, gfp_amplitude / height_micrometer, col=cell)) +
  geom_rect(aes(xmin=t_start*60 - 2*3600, xmax=t_end*60 - 2*3600, ymin=-Inf, ymax=Inf, x=NaN, y=NaN, group=1), fill=rgb(1, 0, 0, .1), size=0.2, col='red', data=filter(switch_ts, cond=='lactose')) +
  geom_path(alpha=0.6) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours(4) +
  labs(y='fluorescence concentration (GFP molecules / µm)') +
  expand_limits(x=0, y=0)
ggsave('plots/asc_switch_fluoconc.pdf', width=8, height=3)

ggplot(filter(myframes, !discard_start, !discard_top, condition=='switch', end_type=='div') %>% mutate(glid=paste(date, pos, gl, sep='.')) %>% filter(glid %in% nth(unique(glid), 11)),
       aes(time_sec - 2*3600, gfp_amplitude , col=cell)) +
  geom_rect(aes(xmin=t_start*60 - 2*3600, xmax=t_end*60 - 2*3600, ymin=-Inf, ymax=Inf, x=NaN, y=NaN, group=1), fill=rgb(1, 0, 0, .1), size=0.2, col='red', data=filter(switch_ts, cond=='lactose')) +
  geom_path(alpha=0.6) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours(4) +
  labs(y='total fluorescence (GFP molecules)') +
  expand_limits(x=0, y=0)
ggsave('plots/asc_switch_fluotot.pdf', width=8, height=3)



ggplot(filter(myframes, !discard_start, !discard_top, condition=='switch', end_type=='div') %>% head(1e4),
       aes(time_sec - 2*3600, gfp_amplitude, col=cell)) +
  geom_rect(aes(xmin=t_start*60 - 2*3600, xmax=t_end*60 - 2*3600, ymin=-Inf, ymax=Inf, x=NaN, y=NaN, group=1), fill=rgb(1, 0, 0, .1), col='red', data=filter(switch_ts, cond=='lactose')) +
  geom_path(alpha=0.2) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours(5) +
  labs(y='total fluorescence (GFP molecules)') +
  expand_limits(x=0, y=0)


```

## Fluo repartition

```{r}
triad_avgw <- 3
swi_triads <- filter(myframes, !discard_start, !discard_top, condition=='switch') %>%
  group_by(date, pos, gl) %>%
  do( (function(.df1){
    # first loop on all growth lanes
    filter(.df1, end_type=="div") %>%
      group_by(id) %>%
       do( (function(.df1, .dfp){
          # then loop on all cells
         # browser()
         if (dim(.dfp)[1] < triad_avgw) return(data.frame())
         .dfcb <- filter(.df1, parent_id==unique(.dfp$id), daughter_type=='BOTTOM')
         if (dim(.dfcb)[1] < triad_avgw) return(data.frame())
         .dfct <- filter(.df1, parent_id==unique(.dfp$id), daughter_type=='TOP')
         if (dim(.dfct)[1] < triad_avgw) return(data.frame())
         
         .dfp <- filter(.dfp, row_number() > dim(.dfp)[1] - triad_avgw) %>%
           select(end_time, height_micrometer, gfp_amplitude) %>%
           summarise_each(funs(mean))
         
         .dfcb <- filter(.dfcb, row_number() <= triad_avgw) %>%
           select(id, daughter_type, height_micrometer, gfp_amplitude) %>%
           summarise_each(funs(mean))
         .dfcb <- setNames(.dfcb, paste("b", names(.dfcb), sep="."))
         .dfct <- filter(.dfct, row_number() <= triad_avgw) %>%
           select(id, daughter_type, height_micrometer, gfp_amplitude) %>%
           summarise_each(funs(mean))
         .dfct <- setNames(.dfct, paste("t", names(.dfct), sep="."))
         
         .out <- bind_cols(.dfp, .dfcb, .dfct)
         return(.out)
       })(.df1, .) )
  })(.) )
swi_triads <- mutate(swi_triads, 
                     medium=sapply(end_time/60, function(.t) switch_ts$cond[min(which(c(switch_ts$t_start, Inf) > .t*dt))-1]) )

qplot(end_time, gfp_amplitude, col=medium, data=swi_triads)


qplot(b.height_micrometer / (b.height_micrometer + t.height_micrometer) , b.gfp_amplitude / (b.gfp_amplitude + t.gfp_amplitude), data=nu_triads, geom="blank") +
  geom_abline() +
  geom_smooth(method='lm', se=FALSE) + 
  geom_point(alpha=0.2, size=1) + 
  ylim(0.4, 0.6) +
  labs(x='size bias toward bottom daughter', y='fluorescence bias toward bottom daughter') 
ggsave('plots/asc_nutriads_size.pdf', width=4, height=3)

qplot(gfp_amplitude , b.gfp_amplitude / (b.gfp_amplitude + t.gfp_amplitude), data=nu_triads, geom="blank") +
  geom_hline(yintercept=0.5, lty='dashed') + 
  geom_point(alpha=0.2, size=1) + 
  ylim(0, 1) +
  labs(x='total fluorescence (GFP molecules)', y='fluorescence bias toward bottom daughter') 
ggsave('plots/asc_nutriads_fluotot.pdf', width=4, height=3)


# pdf('plots/nu_switch.pdf', width=6, height=4.5)
L_nu <- function(.nu, y_t, y_b) {
  if (.nu<0) return(NA)
  mean(lgamma(.nu*y_t + .nu*y_b + 1) - lgamma(.nu*y_t + 1) - lgamma(.nu*y_b + 1) - .nu*(y_b+y_t)*log(2))
  #   mean((y_t+y_b) * digamma(.nu*y_t + .nu*y_b + 1) - y_t * digamma(.nu*y_t + 1) - y_b * digamma(.nu*y_b + 1) - (y_b + y_t)*log(2))
}
write.table(select(nu_triads, fluo_signal, b.fluo_signal, t.fluo_signal), "nu_triads.txt", row.names=FALSE)

tmp <- data.frame(nu=seq(0, 100, 0.1)) %>%
  mutate(L=(Vectorize(L_nu, ".nu"))(nu, y_t=nu_triads$t.fluo_signal, y_b=nu_triads$b.fluo_signal))
qplot(nu, L, data=tmp, geom="line")

optim(30, L_nu, y_t=nu_triads$t.fluo_signal, y_b=nu_triads$b.fluo_signal, control=list(fnscale=-1))


nu_triads <- filter(swi_triads, (end_time>640*60 & end_time<800*60) | 
                      (end_time>1120*60 & end_time<1280*60)) %>%
  ungroup %>%
  mutate(nu=(b.fluo_signal - t.fluo_signal)^2 / fluo_signal,
#          nu2=(b.fluo_signal - t.fluo_signal)^2 / (b.fluo_signal + t.fluo_signal),
         fluo_bin=cut2(fluo_signal, cuts=seq(0, 1e5, 5e3), oneval=FALSE),
         fluo_bin2=Hmisc::cut2(fluo_signal, g=7, oneval=FALSE))
nu_star <- mean(nu_triads$nu)
nu_err <- nu_star / sqrt(dim(nu_triads)[1])
qplot(fluo_signal, b.fluo_signal + t.fluo_signal, data=nu_triads, geom="blank") +
  geom_abline() +
  geom_point(col="red", alpha=0.2)
qplot(fluo_signal, (b.fluo_signal + t.fluo_signal)/fluo_signal, data=nu_triads, geom="blank") +
  geom_hline(yintercept=1) +
  geom_point(col="red", alpha=0.2)
# qplot(fluo_signal, nu, data=filter(nu_triads), alpha=I(0.2))

nu_binned <- group_by(nu_triads, fluo_bin2) %>%
  summarise(n=n(), nu_star=mean(nu), nu_err=nu_star/sqrt(n))
#             nu2_star=mean(nu2), nu2_err=nu2_star/sqrt(n))
qplot(fluo_bin2, nu_star, data=nu_binned, geom="bar", stat="identity", fill=I("gray40")) +
  geom_errorbar(aes(ymin=nu_star-nu_err, ymax=nu_star+nu_err), width=0.2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```




# Old

```{r}

# compute connections to parent
swi_frames_divs <- group_by(swi_frames, date, pos, gl) %>%
  do( (function(.df1){
    # first loop on all growth lanes
    .df1 <- mutate(.df1, cell=interaction(date, pos, gl, id, drop=TRUE))
    group_by(.df1, id) %>%
      do( (function(.df1, .df2){
        # then loop on all cells
        if (unique(.df2$parent_id) < 0) return(data.frame())
        .dfp <- filter(.df1, 
                       cell==factor(interaction(unique(.df2$date), unique(.df2$pos), unique(.df2$gl), unique(.df2$parent_id)), 
                                    levels=levels(.df1$cell)))
        .out <- rbind(filter(.df2, frame==min(frame)),
                      filter(.dfp, frame==max(frame)))
        .out <- mutate(.out, id_ini=id, id=unique(.df2$id))
        return(.out)
      })(.df1, .) )
  })(.) )

triad_avgw <- 3
swi_triads <- group_by(swi_frames, date, pos, gl) %>%
  do( (function(.df1){
    # first loop on all growth lanes
    filter(.df1, end_type=="div") %>%
      group_by(id) %>%
       do( (function(.df1, .dfp){
          # then loop on all cells
#          browser()
         if (dim(.dfp)[1] < triad_avgw) return(data.frame())
         .dfcb <- filter(.df1, parent_id==unique(.dfp$id), daughter_type=='BOTTOM')
         if (dim(.dfcb)[1] < triad_avgw) return(data.frame())
         .dfct <- filter(.df1, parent_id==unique(.dfp$id), daughter_type=='TOP')
         if (dim(.dfct)[1] < triad_avgw) return(data.frame())
         
         .dfp <- filter(.dfp, row_number() > dim(.dfp)[1] - triad_avgw) %>%
           select(end, height, fluo_signal) %>%
           summarise_each(funs(mean))
         
         .dfcb <- filter(.dfcb, row_number() <= triad_avgw) %>%
           select(id, daughter_type, height, fluo_signal) %>%
           summarise_each(funs(mean))
         .dfcb <- setNames(.dfcb, paste("b", names(.dfcb), sep="."))
         .dfct <- filter(.dfct, row_number() <= triad_avgw) %>%
           select(id, daughter_type, height, fluo_signal) %>%
           summarise_each(funs(mean))
         .dfct <- setNames(.dfct, paste("t", names(.dfct), sep="."))
         
         .out <- bind_cols(.dfp, .dfcb, .dfct)
         return(.out)
       })(.df1, .) )
  })(.) )
swi_triads <- mutate(swi_triads, medium=sapply(end, function(.t) switch_ts$cond[min(which(c(switch_ts$t_start, Inf) > .t*dt))-1]) )
qplot(fluo_signal , b.fluo_signal + t.fluo_signal, col=medium, data=swi_triads, geom="blank") +
  geom_abline() +
  geom_point(alpha=0.2) + 
  facet_grid(medium~.)

# pdf('plots/nu_switch.pdf', width=6, height=4.5)
L_nu <- function(.nu, y_t, y_b) {
  if (.nu<0) return(NA)
  mean(lgamma(.nu*y_t + .nu*y_b + 1) - lgamma(.nu*y_t + 1) - lgamma(.nu*y_b + 1) - .nu*(y_b+y_t)*log(2))
  #   mean((y_t+y_b) * digamma(.nu*y_t + .nu*y_b + 1) - y_t * digamma(.nu*y_t + 1) - y_b * digamma(.nu*y_b + 1) - (y_b + y_t)*log(2))
}
write.table(select(nu_triads, fluo_signal, b.fluo_signal, t.fluo_signal), "nu_triads.txt", row.names=FALSE)

tmp <- data.frame(nu=seq(0, 100, 0.1)) %>%
  mutate(L=(Vectorize(L_nu, ".nu"))(nu, y_t=nu_triads$t.fluo_signal, y_b=nu_triads$b.fluo_signal))
qplot(nu, L, data=tmp, geom="line")

optim(30, L_nu, y_t=nu_triads$t.fluo_signal, y_b=nu_triads$b.fluo_signal, control=list(fnscale=-1))


nu_triads <- filter(swi_triads, (end>640/dt & end<800/dt) | (end>1120/dt & end<1280/dt)) %>%
  ungroup %>%
  mutate(nu=(b.fluo_signal - t.fluo_signal)^2 / fluo_signal,
#          nu2=(b.fluo_signal - t.fluo_signal)^2 / (b.fluo_signal + t.fluo_signal),
         fluo_bin=cut2(fluo_signal, cuts=seq(0, 1e5, 5e3), oneval=FALSE),
         fluo_bin2=Hmisc::cut2(fluo_signal, g=7, oneval=FALSE))
nu_star <- mean(nu_triads$nu)
nu_err <- nu_star / sqrt(dim(nu_triads)[1])
qplot(fluo_signal, b.fluo_signal + t.fluo_signal, data=nu_triads, geom="blank") +
  geom_abline() +
  geom_point(col="red", alpha=0.2)
qplot(fluo_signal, (b.fluo_signal + t.fluo_signal)/fluo_signal, data=nu_triads, geom="blank") +
  geom_hline(yintercept=1) +
  geom_point(col="red", alpha=0.2)
# qplot(fluo_signal, nu, data=filter(nu_triads), alpha=I(0.2))

nu_binned <- group_by(nu_triads, fluo_bin2) %>%
  summarise(n=n(), nu_star=mean(nu), nu_err=nu_star/sqrt(n))
#             nu2_star=mean(nu2), nu2_err=nu2_star/sqrt(n))
qplot(fluo_bin2, nu_star, data=nu_binned, geom="bar", stat="identity", fill=I("gray40")) +
  geom_errorbar(aes(ymin=nu_star-nu_err, ymax=nu_star+nu_err), width=0.2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# Plot overall experiment
pls <- group_by(swi_frames, date, pos, gl) %>%
  do(pll=(function(.df){
    .df_div <- filter(swi_frames_divs, date==unique(.df$date), pos==unique(.df$pos), gl==unique(.df$gl))
    list(
      hf = ggplot(data=mutate(.df, b_rank=-round(b_rank)) %>% filter(b_rank>-8, !discard_top)) + 
        geom_rect(aes(xmin=t_start, xmax=t_end, ymin=0, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), col='red', data=filter(switch_ts, cond=='lactose')) +
        geom_path(aes(dt*frame, dh*height, col=factor(id), group=interaction(date, pos, gl, id)), alpha=.85) +
        facet_grid(b_rank~.) +
        scale_y_log10(breaks=c(2, 4, 8)) +
        scale_colour_periodic_brewer() +
        labs(x="time (min)", y="height (µm)") +
        guides(col="none"),
      
      h = ggplot(data=mutate(.df, b_rank=-round(b_rank)) %>% filter(b_rank>-8, !discard_top)) + 
        geom_rect(aes(xmin=t_start, xmax=t_end, ymin=0, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), col='red', data=filter(switch_ts, cond=='lactose')) +
        geom_path(aes(dt*frame, dh*height, col=-b_rank, group=interaction(date, pos, gl, id)), alpha=.85) +
        geom_path(aes(dt*frame, dh*height, group=interaction(date, pos, gl, id)), data=.df_div, linetype="dotted") +
        scale_y_log10(breaks=c(2, 4, 8)) +
        labs(x="time (min)", y="height (µm)", col="position rank"),
      
      ftf = ggplot(data=mutate(.df, b_rank=-round(b_rank)) %>% filter(b_rank>-8, !discard_top)) + 
        geom_rect(aes(xmin=t_start, xmax=t_end, ymin=-Inf, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), col='red', data=filter(switch_ts, cond=='lactose')) +
        geom_path(aes(dt*frame, fluo_signal, col=factor(id), group=interaction(date, pos, gl, id)), alpha=.85) +
        facet_grid(b_rank~.) +
        scale_colour_periodic_brewer() +
        labs(x="time (min)", y="total GFP") +
        guides(col="none"),
      
      ft = ggplot(data=mutate(.df, b_rank=-round(b_rank)) %>% filter(b_rank>-8, !discard_top)) + 
        geom_rect(aes(xmin=t_start, xmax=t_end, ymin=0, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), col='red', data=filter(switch_ts, cond=='lactose')) +
        geom_path(aes(dt*frame, fluo_signal, col=-b_rank, group=interaction(date, pos, gl, id)), alpha=.85) +
        geom_path(aes(dt*frame, fluo_signal, group=interaction(date, pos, gl, id)), data=.df_div, linetype="dotted") +
        labs(x="time (min)", y="total GFP", col="position rank"),
      
      fcf = ggplot(data=mutate(.df, b_rank=-round(b_rank)) %>% filter(b_rank>-8, !discard_top)) + 
        geom_rect(aes(xmin=t_start, xmax=t_end, ymin=-Inf, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), col='red', data=filter(switch_ts, cond=='lactose')) +
        geom_path(aes(dt*frame, fluo_signal/height, col=factor(id), group=interaction(date, pos, gl, id)), alpha=.85) +
        facet_grid(b_rank~.) +
        scale_colour_periodic_brewer() +
        labs(x="time (min)", y="GFP concentration") +
        guides(col="none"),
      
      fc = ggplot(data=mutate(.df, b_rank=-round(b_rank)) %>% filter(b_rank>-8, !discard_top)) + 
        geom_rect(aes(xmin=t_start, xmax=t_end, ymin=0, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), col='red', data=filter(switch_ts, cond=='lactose')) +
        geom_path(aes(dt*frame, fluo_signal/height, col=-b_rank, group=interaction(date, pos, gl, id)), alpha=.85) +
        geom_path(aes(dt*frame, fluo_signal/height, group=interaction(date, pos, gl, id)), data=.df_div, linetype="dotted") +
        labs(x="time (min)", y="GFP concentration", col="position rank")
      
    )
  })(.))

pdf('plots/switch_path_height.pdf', width=12, height= 6)
for (i in 1:dim(pls)[1])
  plot(pls[[i, 'pll']] [['hf']] + 
         labs(title=sprintf("%s  pos:%02d  GL:%02d", pls[[i, "date"]], pls[[i, "pos"]], pls[[i, "gl"]])))
dev.off()

pdf('plots/switch_path_fluotot.pdf', width=12, height=6)
for (i in 1:dim(pls)[1])
  plot(pls[[i, 'pll']] [['ftf']] + 
         labs(title=sprintf("%s  pos:%02d  GL:%02d", pls[[i, "date"]], pls[[i, "pos"]], pls[[i, "gl"]])))
dev.off()



# Kymograph plots

# ggplot(data=swi_frames, aes(group=interaction(date, pos, gl, id))) + 
#   #   geom_ribbon(aes(frame, ymin=-hmin, ymax=-hmax, fill=factor(id)), alpha=.15) +
#   geom_ribbon(aes(frame, ymin=-(hcenter-height/2), ymax=-(hcenter+height/2), fill=factor(id)), alpha=.3) +
#   geom_path(aes(frame, -hcenter, col=factor(id)), alpha=.5) +
#   scale_colour_periodic_brewer() +
#   scale_fill_periodic_brewer() +
#   guides(col="none", fill="none")

plk <- group_by(swi_frames, date, pos, gl) %>%
  do(pl=(function(.df){
    #     browser()
    .df_div <- filter(swi_frames_divs, date==unique(.df$date), pos==unique(.df$pos), gl==unique(.df$gl))
    ggplot(data=.df, aes(group=interaction(date, pos, gl, id))) + 
      geom_rect(aes(xmin=t_start, xmax=t_end, ymin=-Inf, ymax=Inf, group=1), fill=rgb(1, 0, 0, .1), data=filter(switch_ts, cond=='lactose')) +
      geom_rect(aes(xmin=dt*(frame-.5), xmax=dt*(frame+.5), ymin=-dh*(hcenter-height/2), ymax=-dh*(hcenter+height/2), fill=fluo_signal/height)) +
      geom_path(aes(dt*frame, -dh*hcenter)) +
      geom_path(aes(dt*frame, -dh*hcenter), data=.df_div, linetype="dotted") +
      geom_rect(aes(xmin=t_start, xmax=t_end, ymin=-Inf, ymax=Inf, group=1), col='red', fill="transparent", data=filter(switch_ts, cond=='lactose')) +
      scale_fill_gradient2(low="gray50", high="green", midpoint=200) + 
      labs(x="time (min)", y="position (µm)", "GFP concentration")
  })(.))

pdf('plots/switch_kymo_fluoconc.pdf', width=12, height=6)
for (i in 1:dim(pls)[1])
  plot(plk[[i, 'pl']] + 
         labs(title=sprintf("%s  pos:%02d  GL:%02d", pls[[i, "date"]], pls[[i, "pos"]], pls[[i, "gl"]])))
dev.off()




```
