---
title: "Constant environments"
author: Thomas Julou
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

## Growth in constant environments

```{r}
myframes <- myframes %>% 
  # group_by(date, pos, gl, id) %>% 
  partition(date, pos, gl, id, cluster=mycluster) %>%
  do((function(.df){
    .n <- dim(.df)[1]
    .cell_cycle <- NA
    if (!any(.df$discard_start) && unique(.df$end_type)=='div')
      .cell_cycle <- ((1:.n)-.5) / .n
    .logl <- NA
    if (unique(.df$condition) %in% c('glucose', 'lactose', 'lactose_lowillum')  &&  .n > 4) {
      .mod_ll_t <- lm( log(length_um)~time_sec, .df)  # use lm() for predict with se
      .pred_ll <- predict(.mod_ll_t, se.fit=TRUE)
      .logl <- .pred_ll$fit
    }
    mutate(.df, cell_cycle=.cell_cycle, length_predict=exp(.logl),
          gfp_deriv=(gfp_nb-lag(gfp_nb))/(time_sec-lag(time_sec)))
  })(.)) %>% 
  collect()

```


Let's compute stats over the cell cycle for each cell.

```{r}
mycells <- filter(myframes, condition %in% c('glucose', 'lactose', 'lactose_lowillum'), !discard_top) %>%
  filter(!(date=='20160427' & time_sec>7e4)) %>%  # remove dilution step at the end of expt
  # group_by(condition, date, pos, gl, id, cell, parent_id, genealogy) %>%
  partition(condition, date, pos, gl, id, cell, parent_id, genealogy, cluster=mycluster) %>%
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>% # at least 4 time points
  do((function(.df) {
    # browser()
    
    .mod_ll_t <- lm( log(length_um)~time_sec, .df)  # use fastLm() for predict
    # .mod_ll_t <- fastLmPure( cbind(1, .df$time_sec), log(.df$length_um) )
    .mod_lg_t <- fastLmPure( cbind(1, .df$time_sec), log(.df$gfp_nb) )
    .mod_l_t <- fastLmPure( cbind(1, .df$time_sec), .df$length_um )
    .mod_g_t <- fastLmPure( cbind(1, .df$time_sec), .df$gfp_nb )
    .mod_g_l <- fastLmPure( cbind(1, .df$length_um), .df$gfp_nb )

    .time_birth <- first(.df$time_sec)
    .time_div <- last(.df$time_sec)
    .logl <- predict(.mod_ll_t, se.fit=TRUE)
    data.frame(npoints=.mod_ll_t$df.residual+1,
               time_birth=.time_birth, time_div=.time_div, 
               cell_num_from_top=mean(.df$cell_num_in_lane),
               cell_num_from_bottom=mean(.df$total_cell_in_lane-.df$cell_num_in_lane), 
               loglength_start=first(.logl$fit), loglength_startse=first(.logl$se.fit), 
               loglength_end=last(.logl$fit), loglength_endse=last(.logl$se.fit), 
               logl_time_slope=.mod_ll_t$coefficients[2], logl_time_slopesd=summary(.mod_ll_t)$coefficients[2,2], 
               # logl_time_slope=.mod_ll_t$coefficients[2], logl_time_slopesd=.mod_ll_t$stderr[2], 
               logl_time_r2=cor(.df$time_sec, log(.df$length_um))^2,
               logg_time_slope=.mod_lg_t$coefficients[2], logg_time_slopesd=.mod_lg_t$stderr[2], 
               logg_time_r2=cor(.df$time_sec, log(.df$gfp_nb))^2,
               l_time_slope=.mod_l_t$coefficients[2], l_time_slopesd=.mod_l_t$stderr[2], 
               l_time_r2=cor(.df$time_sec, .df$length_um)^2,
               g_first=first(.df$gfp_nb), g_last=last(.df$gfp_nb),
               g_time_slope=.mod_g_t$coefficients[2], g_time_slopesd=.mod_g_t$stderr[2], 
               g_time_r2=cor(.df$time_sec, .df$gfp_nb)^2,
               g_l_slope=.mod_g_l$coefficients[2], g_l_slopesd=.mod_g_l$stderr[2], 
               g_l_r2=cor(.df$length_um, log(.df$gfp_nb))^2)
  })(.) ) %>% 
  collect() %>% 
  arrange(condition, date, pos, gl, id) %>% 
  mutate(gl_id=gsub('\\.[0-9]+$', '', cell))


```

Let's compute instantaneous rates:

```{r} 
rate_width <- 6 # number of frames used for fitting
rate_hw <- round(rate_width/2) * dt * 60

myrates <- semi_join(myframes, mycells, by='cell') %>%  # keep only full cells in constant conditions
  # loop on all cells
  # group_by(condition, date, pos, gl, id, cell) %>%
  partition(condition, date, pos, gl, id, cell,
            cluster=mycluster %>% cluster_assign_obj(dt) %>% cluster_assign_obj(rate_hw) %>%
              cluster_assign_func(get_parent_cid) %>% cluster_assign_func(get_daughters_cid)) %>%
  do( (function(.dfc){
    .dfc %>% 
      group_by(time_sec) %>% 
      do((function(.p) {
        # browser()
        .df <- filter(.dfc, between(time_sec, .p[['time_sec']]-rate_hw, .p[['time_sec']]+rate_hw))
        .mod_ll <- fastLmPure( cbind(1, .df$time_sec), log(.df$length_um) )
        .mod_g <- fastLmPure( cbind(1, .df$time_sec), .df$gfp_nb )
        .mod_g_l <- fastLmPure( cbind(1, .df$length_um), .df$gfp_nb )
        data.frame(irate_npoints=.mod_ll$df.residual+1,
                   islope_ll_time=.mod_ll$coefficients[2], islopesd_ll_time=.mod_ll$stderr[2],
                   ir2_ll_time=corPearson(.df$time_sec, log(.df$length_um))^2,
                   ir2_l_time=corPearson(.df$time_sec, .df$length_um)^2,
                   islope_g_time=.mod_g$coefficients[2], islopesd_g_time=.mod_g$stderr[2],
                   ir2_g_time=corPearson(.df$time_sec, .df$gfp_nb)^2,
                   ir2_lg_time=corPearson(.df$time_sec, log(.df$gfp_nb))^2,
                   islope_g_l=.mod_g_l$coefficients[2], islopesd_g_l=.mod_g_l$stderr[2],
                   ir2_g_l=corPearson(.df$length_um, .df$gfp_nb)^2)
      })(.) )
  })(.) ) %>% 
  collect()

myrates <- myrates %>% 
  left_join(myframes %>% select(gl_id, cell, genealogy, start_time, end_time) %>% distinct) %>% 
  left_join(myframes %>% select(cell, time_sec, cell_num_in_lane, total_cell_in_lane, length_um, gfp_nb,
                                length_predict, gfp_deriv))

```


### Cell elongation dynamics over the experiment

Print an example of what cell traces look like and r2 CDF to show that elongation is more exponential than linear:

```{r}
ggplot(filter(myframes, !discard_start, !discard_top, condition=='glucose', end_type=='div', start_time>=2*3600) %>% ungroup %>%  filter(cell %in% cell[c(1, 100, 30, 300, 400)]),
       aes((time_sec-start_time)/60, length_um, col=cell)) +
  stat_smooth(method='lm', se=FALSE) +
  geom_path(alpha=0.8, size=1) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_continuous(breaks=seq(0, 80, 40)) +
  scale_y_continuous(trans='log2', breaks=2:4) +
  expand_limits(y=4) +
  labs(x='time after division (min)', y='length (µm)')
# ggsave('plots/asc_loglength_time.pdf', width=2.5, height=3)

ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')) ) +
  stat_ecdf(aes(logl_time_r2, col=condition, lty='exponential')) +
  stat_ecdf(aes(l_time_r2, col=condition, lty='linear')) +
  labs(x='Pearson correlation r2', y='cumulative probability', lty='fit') +
  xlim(0.94, 1) +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))
# ggsave('plots/asc_loglength_time_r2ecdf.pdf', width=2.5, height=3.5)


```


Neither the cell length nor the doubling time increases during experiments in constant conditions, indicating limited photodamage and physiological aging.

```{r}
myframes %>% filter(condition %in% c('glucose', 'lactose')) %>% 
         filter(!discard_start, !discard_top, end_type=='div', start_time>=2*3600) %>%
         sample_frac(.1, replace=FALSE) %>% 
  ggplot(aes(time_sec - 2*3600, length_um, col=condition)) +
  facet_grid(condition~.) +
  # stat_density2d()
  geom_point(alpha=.1) +
  scale_x_hours()
# geom_point(aes(time_sec, length_um), alpha=0.1)

ggplot(filter(myframes, condition %in% c('glucose', 'lactose'), !discard_top), 
       aes(time_sec, length_um, col=condition)) +
  geom_smooth()

```



```{r}
# table(mycells %>% filter(condition %in% c('glucose', 'lactose'))$Rsize_vs_time^2>.95)
mycells %>% filter(condition %in% c('glucose', 'lactose'), logl_time_r2>.95) %>% 
  ( function(.df)
    ggplot(.df, aes(time_div - 2*3600, log(2)/logl_time_slope / 60, col=condition)) +
      geom_point(alpha=0.2, size=1) +
      # stat_smooth(method='loess', span=.7, se=FALSE, size=1) +
      stat_smooth(method='lm', size=1,
                  data=filter(.df, time_birth > 5*3600)) +
      scale_x_hours(6, name='time at division (h)') +
      labs(y='doubling time (min)') +
      expand_limits(x=c(0, 24*3600), y=0) +
      theme(legend.justification=c(0, 1), legend.position=c(0, 1)) )
# ggsave('plots/asc_dt_divtime.pdf', width=6, height=3)

```


Let's look at the distribution of doubling times.

```{r}
ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')), 
       # %>% filter(Rsize_vs_time^2>.98),
       aes(log(2)/logl_time_slope / 60)) +
  stat_bin(aes(y=..density.., fill=condition), geom='bar', position='identity', col='transparent', alpha=.2) + 
  geom_step_hist(aes(y=..density.., col=condition), position='identity') +
    # stat_ecdf() +
  xlim(0, 300) +
  labs(x='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))
# ggsave('plots/asc_dt.pdf', width=3.5, height=3.5)

```

NB: the decrease is the quality of the elongation fit is only moderate for cells with long doubling time (for dt>100, r2 <= 5% for r2 propto dt)
 
```{r eval=FALSE}
ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')),
       aes(log(2)/logl_time_slope / 60, logl_time_r2, col=condition)) +
  facet_wrap(~condition) +
  geom_point(alpha=.2) +
  geom_smooth(method='lm') +
  # stat_density2d() +
  labs(x='doubling time (min)') +
  xlim(50, 200) + ylim(0.95, 1)

mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  group_by(condition) %>% 
  mutate(dt=log(2)/logl_time_slope / 60 ) %>% 
  filter(dt > 100) %>% 
  do((function(.df){
    .mod <- fastLmPure( cbind(1, .df$dt), .df$logl_time_r2 )
    data.frame(slope=.mod$coefficients[2],
            r2=cor(.df$dt, .df$logl_time_r2)^2)
    })(.)) %>% kable

```


Let's check that cells with long doubling time are not filamentous: the slowest 10% in each condition have a similar length but they tend to be slightly longer. 

```{r}
l_end <- select(mycells, date, pos, gl, id, time_sec=time_div) %>%
  left_join(select(myframes, date, pos, gl, id, time_sec, length_um)) %>%
  rename(length_um_end=length_um)
mycells <- left_join(mycells, l_end %>% select(-time_sec)) %>% ungroup

mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  group_by(condition) %>% 
  mutate(dt=log(2)/logl_time_slope / 60,
         is_long_dt= dt>quantile(dt, 0.9)) %>% 
  ( function(.df)
    ggplot(.df, aes(length_um_end, ..density.., col=condition)) +
      facet_wrap(~condition) +
      geom_step_hist(aes(linetype='all'), position='identity') +
      geom_step_hist(aes(linetype='long dt (10%)'), position='identity', 
                     data=filter(.df, is_long_dt)) +
      labs(linetype='subset') )

```

```{r eval=FALSE}
ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')), 
       aes(length_um_end, log(2)/logl_time_slope / 60, col=condition)) +
  facet_wrap(~condition) +
  geom_point(alpha=0.2)

mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  group_by(condition) %>% 
  mutate(dt=log(2)/logl_time_slope / 60,
         is_long_dt= dt>quantile(dt, 0.9)) %>% 
  filter(is_long_dt) %>% 
  do((function(.df){
    .mod <- fastLmPure( cbind(1, .df$length_um_end), .df$dt )
    data.frame(slope=.mod$coefficients[2],
            r2=cor(.df$length_um_end, .df$dt)^2)
    })(.)) %>% kable

```


### Residuals over the cell cycle

```{r}
ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% c('glucose', 'lactose')),
       aes((time_sec-start_time)/60, length_um-length_predict)) +
  facet_wrap(~condition) +
  geom_hline(yintercept=0, col='red') +
  # geom_path(aes(col=interaction(date, pos), group=cell), size=.5, alpha=.1) +
  stat_summary(fun.data=mean_sdl, geom="pointrange") +
  xlim(0, 200)

```


### Autocorrelation of elongation

```{r}
ggplot(myrates, aes(x=(time_sec-start_time)/60)) +
  # geom_line(aes(y=islope_ll_time, col=condition, group=cell), alpha=0.1) + 
  stat_summary(aes(y=islope_ll_time, col=condition), fun.data=mean_cl_normal, geom="pointrange") +
  # stat_summary(aes(y=islope_ll_time, col=condition), fun.y=mean, geom="point") +
  xlim(0, 200) +
  expand_limits(y=0)

ggplot(myrates, aes(x=mycut((time_sec-start_time)/(end_time-start_time), seq(0,1,.03)))) +
  # geom_line(aes(y=islope_ll_time, col=condition, group=cell), alpha=0.1) +
  stat_summary(aes(y=islope_ll_time, col=condition), fun.data=mean_cl_normal, geom="pointrange") +
  expand_limits(y=0) +
  labs(x='cell cycle')

```


```{r}
myrates %>% filter(condition %in% c('glucose', 'lactose'),
                   cell_num_in_lane==total_cell_in_lane) %>% 
  ggplot(aes(time_sec, islope_ll_time)) +
  geom_line(aes(col=condition, group=gl_id), alpha=.25) +
  # stat_summary(aes(col=condition), fun.y=mean, geom="point") +
  stat_smooth(aes(col=condition), method='lm') +
  geom_hline(yintercept=1e-4, lty='dotted')

myrates %>% filter(condition %in% c('glucose', 'lactose'),
                   cell_num_in_lane==total_cell_in_lane) %>% 
  group_by(condition, date, pos, gl) %>% 
  do((function(.df){
    # browser()
    .acf <- acf(.df$islope_ll_time, lag.max=100, plot=FALSE)
    data.frame(lag=.acf$lag*dt, acf=.acf$acf)
  })(.)) %>% 
  ggplot(aes(lag, acf)) +
  facet_grid(.~condition) +
  geom_line(aes(col=condition, group=interaction(date, pos, gl)), alpha=.2) +
  stat_summary(aes(col=condition), fun.data=mean_cl_normal, geom="pointrange")

```


Let's look at the corresponding doubling time distribution:

```{r}
mycells %>% 
  semi_join(filter(myrates, cell_num_in_lane==total_cell_in_lane), by='cell') %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  ggplot(aes(log(2)/logl_time_slope / 60)) +
  stat_bin(aes(y=..density.., fill=condition), binwidth=5,
           geom='bar', position='identity', col='transparent', alpha=.2) + 
  geom_step_hist(aes(y=..density.., col=condition), binwidth=5, position='identity') +
  # stat_ecdf() +
  # xlim(0, 300) +
  labs(x='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))

mycells %>% 
  semi_join(filter(myrates, cell_num_in_lane==total_cell_in_lane), by='cell') %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  ggplot(aes(log(2)/logl_time_slope / 60)) +
  stat_ecdf(aes(y=1-..y.., col=condition)) + 
  # xlim(0, 300) +
  scale_y_log10() +
  labs(x='doubling time (min)', y='reverse cumulative probability') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))

mycells %>% 
  semi_join(filter(myrates, cell_num_in_lane==total_cell_in_lane), by='cell') %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  ggplot(aes(time_div/3600, log(2)/logl_time_slope / 60, col=condition)) +
  geom_point() +
  stat_smooth(method='lm') +
  labs(y='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))

```

NB: the doubling time distribution depends on the bottom rank...

```{r}
mycells %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  mutate(cell_num_from_bottom=round(cell_num_from_bottom)) %>% 
  filter(cell_num_from_bottom<6) %>% 
  ggplot(aes(time_div/3600, log(2)/logl_time_slope / 60, col=condition)) +
  facet_grid(.~cell_num_from_bottom) +
  geom_point(alpha=.1) +
  stat_smooth(method='lm') +
  coord_cartesian(ylim=c(0, 200)) +
  labs(y='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))


```


### Growth rate inheritance 

Is there a genealogical signal on growth rate in constant environment?
NB: Growth rate is show in doubling time units…

```{r}
mypairs_constant <- mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  # group_by(gl_id) %>% 
  partition(gl_id, cluster=mycluster %>% cluster_assign_func(genealogy_relationship) %>% cluster_assign_func(genealogy_ontology)) %>% 
  do((function(.df) {
    # browser()
    if (dim(.df)[1]<2) 
      return(data.frame())
    return( combn(.df$genealogy, 2, simplify=FALSE) %>% 
      lapply(function(.x) as.data.frame(genealogy_relationship(.x), stringsAsFactors=FALSE)) %>% 
      do.call(rbind, .) )
  })(.)) %>% 
  collect() %>% 
  # mutate(rel=factor(rel, levels=c("sisters", "cousins1", "cousins2", "niece"))) %>% 
  left_join(mycells %>% ungroup %>% 
              setNames(., paste(names(.), "1", sep="_")) %>% rename(gl_id=gl_id_1) ) %>% 
  left_join(mycells %>% ungroup %>% 
              setNames(., paste(names(.), "2", sep="_")) %>% rename(gl_id=gl_id_2) ) %>% 
  # compute "ordered" doubling times
  group_by(div_min, div_max) %>% 
  mutate(
    dt_upstream = ifelse(div_1<div_2, log(2)/logl_time_slope_1 / 60, log(2)/logl_time_slope_2 / 60),
    dt_downstream = ifelse(div_1<div_2, log(2)/logl_time_slope_2 / 60, log(2)/logl_time_slope_1 / 60),
    dt_upstream2 = mycut(dt_upstream, seq(0, 1000, 10)))


ggplot(filter(mypairs_constant, TRUE), aes(log(2)/logl_time_slope_1 / 60, log(2)/logl_time_slope_2 / 60, col=factor(rel))) +
  # facet_wrap(~condition_1) +
  geom_point(alpha=.5, size=.5) +
  expand_limits(x=0, y=0)


filter(mypairs_constant, TRUE) %>% 
  group_by(div_min, div_max) %>% 
  # group_by(condition_1, div_min, div_max) %>% 
  summarise(r2=cor(log(2)/logl_time_slope_1 / 60,  log(2)/logl_time_slope_2 / 60, use="complete.obs", method="pearson")^2, n=n()) %>% 
  mutate(rel=(Vectorize(genealogy_ontology))(div_min, div_max)) %>% 
  (function(.df) ggplot(.df, aes(div_min, div_max)) +
     # facet_wrap(~condition_1) +
     geom_tile(aes(fill=r2), stat='identity', show.legend=FALSE) +
     geom_text(aes(label=sprintf("%s\nr2 = %.3f", rel, r2))) +
     geom_text(aes(y=div_max-.4, label=sprintf("(n = %d)", n))) +
     scale_fill_gradient(high='red', low='lightblue') +
     scale_x_continuous(breaks=0:10, expand=c(0,0)) + scale_y_continuous(trans="reverse", breaks=0:10, expand=c(0,0)) +
     expand_limits(fill=0) + coord_fixed() +
     labs(x='divs since common ancestor (cell 1)', y='div since common ancestor (cell 2)')
  )

```

Let's look at the corresponding distributions:

```{r}
ggplot(mypairs_constant, aes(dt_upstream, dt_downstream)) +
  facet_grid(div_max~div_min) +
  geom_point(size=.2, alpha=.1) +
  # geom_smooth(col=brewer_cols[1]) +
  stat_summary(aes(x=dt_upstream2), fun.data=mean_sdl, geom="pointrange", col=brewer_cols[1]) +
  xlim(0, 200) + ylim(0, 200)

```


The weaker correlation between mothers/daughters than between sisters suggests a finer analysis with 2 estimates per cell. Given that the instantaneous elongation rate is rather constant over the cell cycle (but when adjacent points before/after division are taken into account), I use one estimation at 25% of the cell cycle and another at 75% (outside of the +-5points fitting window for cell cycles longer than 60min).

Cells are selected according to the following scheme:

- pick all pairs of sisters with entire cell cycles
- keep only if their mother also has an entire cell cycle
- for these 3 cells, compute all combination of points involving 2 different cells
- at the end, list all cells used in the table and add their internal points
(estimate their growth rate using either instantaneour estimate based on 10 points at 25% and 75% of the cell cycle; or using an exponential fit over 1/2 the cell cycle)

```{r}
mysubpairs_constant <- 
  (function() {
    # browser()
    # # select rates of all cells
    # myrates_25_75 <- myrates %>% filter(condition %in% c('glucose', 'lactose')) %>% 
    #   mutate(cell_cycle=(time_sec-start_time)/(end_time-start_time)) %>% 
    #   group_by(cell) %>% slice(c(which.min((cell_cycle-0.25)^2), which.min((cell_cycle-0.75)^2))) %>% 
    #   group_by(cell) %>% mutate(cc=c(1, 2)) %>% 
    #   select(cell, gl_id, cell, genealogy, cc, irate=islope_ll_time) %>% ungroup

    myrates_halfcc <- myframes %>% 
      # keep only frames of cells seen during their entire cell cycle
      semi_join(filter(mycells, condition %in% c('glucose', 'lactose'))) %>% 
      ungroup %>% 
      mutate(cell_cycle=(time_sec-start_time)/(end_time-start_time),
             cc=ifelse(cell_cycle<0.5, 1, 2)) %>% 
      group_by(cell, cc,  gl_id, genealogy) %>% 
      do((function(.df) {
        .mod_ll_t <- fastLmPure( cbind(1, .df$time_sec), log(.df$length_um) )
        data.frame(irate=.mod_ll_t$coefficients[2])
      })(.) ) %>% 
      # collect() %>% 
      ungroup

    
    # myrates_25_75 %>% mutate(cc=paste0('ir', cc)) %>% spread(cc, irate) %>%
    # ggplot(aes(ir1, ir2))+geom_point(alpha=.1) + geom_abline(col='red') + stat_smooth(method='lm')
    
                   
    .rel_table <- combn(1:6, 2) %>% t %>% as.data.frame %>% slice(-c(1, 10, 15)) %>% 
      setNames(c('row1', 'row2')) %>% 
      mutate(rel_d=c("d10", "d15", "d10", "d15", "d5", "d10", "d5", "d10", "s5", "s10", "s10", "s15"),
             rel=substr(rel_d, 1, 1) %>% sub('d', 'daughter', .) %>% sub('s', 'sisters', .),
             dist=as.numeric(substring(rel_d, 2)))
    # in the following, .rel_table assumes the following row order in my rates:
    #             ----- -----
    #  1      2  /  3     4
    # ----- -----
    #            \  5     6
    #             ----- -----
    
    mypairs_constant %>% filter(condition_1 %in% c('glucose', 'lactose'), rel=='sisters') %>% 
      group_by(gl_id, ancestor) %>% 
      # partition(gl_id, ancestor, cluster=mycluster %>% ) %>% 
      do( (function(.df){
        # extract data from cell pairs (only if mother has entire cell cycle)
        # browser()
        .rates <- filter(myrates_halfcc, gl_id==.df$gl_id, genealogy %in% c(.df$ancestor, .df$genealogy_1, .df$genealogy_2)) %>% 
          arrange(genealogy, cc) # mind the rows order!
        if (dim(.rates)[1] < 6) return(data.frame())
        
        cbind(.rel_table %>% select(rel, dist),
              .rates %>% select(cell, cc, irate) %>% setNames(paste0(colnames(.), '_1')) %>% slice(.rel_table$row1),
              .rates %>% select(cell, cc, irate) %>% setNames(paste0(colnames(.), '_2')) %>% slice(.rel_table$row2))
      })(.) ) %>% 
      select(-ancestor) %>% 
      # add data from within cells
      (function(.df){
        .cells <- .df %>% filter(rel=='sisters') %>% select(cell_1, cell_2) %>% unlist %>% unique # xxx this is shorter than 2 x nb of pairs !!
        bind_rows(.df, 
                  filter(myrates_halfcc, cell %in% .cells) %>% 
                    mutate(cc=paste0('irate_', cc)) %>% spread(cc, irate) %>% 
                    mutate(rel='cell', dist=5, cell_1=cell, cell_2=cell, cc_1=1, cc_2=2) %>% 
                    select(-genealogy, -cell) )
      }) %>% 
      mutate(dist=dist/10)
})()

mysubpairs_constant %>% 
  group_by(rel, dist) %>% 
  summarise(r2=cor(irate_1, irate_2)^2) %>% #, n=n()
  spread(rel, r2)

```


## Fluo in lactose

Plot an example of GFP traces:

```{r}
filter(myframes, date=='20150624', pos==0, gl==4) %>% 
  filter(!discard_top, !discard_start, b_rank<4) %>% 
  mutate(time_sec=time_sec-2*3600) %>% 
  plot_faceted_var_tracks(.var_col='gfp_nb', .col='darkgreen') +
  scale_x_hours(4) +
  scale_y_continuous(breaks=c(0, 5000, 10000)) +
  expand_limits(y=0) +
  labs(y='total GFP per cell (molecules)') +
  theme(strip.background = element_blank(), strip.text = element_blank())
# ggsave('plots/asc_lac_gfp_time.pdf', width=4, height=3.5)

filter(myframes, date=='20150624', pos==0, gl==4) %>% 
  filter(!discard_top, !discard_start, b_rank<4) %>% 
  mutate(time_sec=time_sec-2*3600) %>% 
  plot_faceted_var_tracks(.var_col='gfp_nb', .log=TRUE, .col='darkgreen') +
  scale_x_hours(4) +
  scale_y_continuous(trans='log', breaks=c(3000, 6000, 12000)) +
  labs(y='total GFP per cell (molecules)') +
  theme(strip.background = element_blank(), strip.text = element_blank())
# ggsave('plots/asc_lac_loggfp_time.pdf', width=8, height=5)

filter(myframes, date=='20150624', pos==0, gl==4) %>% 
  filter(!discard_top, !discard_start, b_rank<4) %>% 
  mutate(time_sec=time_sec-2*3600) %>% 
  plot_faceted_var_tracks(.var_col='length_um', .log=TRUE, .col='gray15') +
  scale_x_hours(4) +
  scale_y_continuous(trans='log2') +
  labs(y='cell length (µm)') +
  theme(strip.background = element_blank(), strip.text = element_blank())
# ggsave('plots/asc_lac_length_time.pdf', width=4, height=3.5)

```

In this case, r2 CDFs don't help concluding whether the GFP increase over the cell cycle is more exponential (null model assuming concentration homeostasis) or linear:

```{r}
ggplot(mycells %>% filter(condition %in% 'lactose') ) +
  stat_ecdf(aes(logg_time_r2, col='GFP', lty='exponential')) +
  stat_ecdf(aes(g_time_r2, col='GFP', lty='linear')) +
  stat_ecdf(aes(logl_time_r2, col='length', lty='exponential')) +
  stat_ecdf(aes(l_time_r2, col='length', lty='linear')) +
  labs(x='Pearson correlation r2', y='cumulative probability', lty='fit', col='variable') +
  xlim(0.74, 1) +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))
# ggsave('plots/asc_gfp_time_r2ecdf.pdf', width=2.5, height=3.5)

```


```{r eval=FALSE}
ggplot(mycells %>% filter(condition %in% 'lactose'),
       aes(l_time_r2, logl_time_r2) ) +
  geom_point(size=.5, alpha=.5) +
  geom_abline(col='red') +
  xlim(0.94, 1) + ylim(0.94, 1)

```

Surprisingly, most cells are described as accurately by a linear or an exponential fit (with r2>0.97). For cells which cannot be captured by such a model (r2<0.95), it looks like that the fit is either exponential or linear (but not equally good):

```{r}
ggplot(mycells %>% filter(condition %in% 'lactose'),
       aes(g_time_r2, logg_time_r2) ) +
  geom_point(size=.5, alpha=.5) +
  geom_abline(col='red') +
  # xlim(0.94, 1) + ylim(0.94, 1) +
  xlim(0.84, 1) + ylim(0.84, 1) +
  coord_equal()
  # labs(x='Pearson correlation r2', y='cumulative probability', lty='fit') +
  # theme(legend.justification=c(0, 1), legend.position=c(0, 1))

ggplot(mycells %>% filter(condition %in% 'lactose'),
       aes(1-g_time_r2, 1-logg_time_r2)) +
  geom_point(size=.5, alpha=.5) +
  # stat_density2d() +
  geom_abline(col='red') +
  scale_x_log10() + scale_y_log10() +
  coord_equal()

```

This suggests that it's simply not relevant to try to describe the GFP increase with such a model (and hence to compare increase rates over the entire cell cycle). 


### Regression to the mean between consecutive divisions

For total GFP, there is no dependance of the GFP increase to the initial GFP (r2=`r with(mycells %>% filter(condition %in% 'lactose'), corPearson(g_first, g_last-g_first))^2`). Nonetheless, the initial / final GFP concentration scatter has a slope < 1, due to a "regression to the mean dynamics, i.e. if a cell starts high, it's likely to divide high but less than at birth).

```{r}
ggplot(mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')),
       aes(g_first, g_last-g_first, col=condition)) +
  geom_abline(col='black') +
  geom_point(size=.3, alpha=.5) +
  expand_limits(x=0, y=0) +
  labs(x='initial total GFP', y='added total GFP') +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))
# ggsave('Rplot.pdf', width=4, height=2.5)

mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')) %>% 
  group_by(condition) %>% 
  summarise(r2=corPearson(g_first, g_last-g_first)^2)

ggplot(mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')),
       aes(g_first/exp(loglength_start), g_last/exp(loglength_end), col=condition )) +
  geom_abline(col='black') +
  geom_point(size=.3, alpha=.5) +
  stat_smooth(method=lm) +
  expand_limits(x=0, y=0) +
  labs(x='initial GFP concentration', y='final GFP concentration') +
  theme(legend.justification=c(1, 0), legend.position=c(1, 0))
# ggsave('Rplot.pdf', width=4, height=3.5)

mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')) %>% 
  group_by(condition) %>% 
  summarise(r2=corPearson(g_first/exp(loglength_start), g_last/exp(loglength_end) )^2)

```

Moreover, the GFP added per unit length is independent of the initial GFP concentration:

```{r}
ggplot(mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')),
       aes(g_first/exp(loglength_start), (g_last-g_first) / (exp(loglength_end)-exp(loglength_start)),
           col=condition)) +
  geom_point(size=.3, alpha=.5) +
  geom_abline(col='black') +
  expand_limits(x=0, y=0) +
  labs(x='initial GFP concentration', y='added GFP / added length') +
  # theme(legend.justification=c(0, 1), legend.position=c(0, 1))
  theme(legend.position='none')
# ggsave('Rplot.pdf', width=4, height=2.5)

mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')) %>% 
  group_by(condition) %>% 
  summarise(r2=corPearson(g_first/exp(loglength_start), 
                          (g_last-g_first) / (exp(loglength_end)-exp(loglength_start)) )^2)

```

Also, the initial GFP concentration correlates only weakly with the (fitted) initial cell size:

```{r}
ggplot(mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')),
       aes(exp(loglength_start), g_first/exp(loglength_start), col=condition)) +
  geom_point(size=.3, alpha=.5) +
  expand_limits(x=0, y=0) +
  labs(x='initial length', y='initial GFP concentration') +
  theme(legend.justification=c(0, 0), legend.position=c(0, 0))

mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')) %>% 
  group_by(condition) %>% 
  summarise(r2=corPearson(exp(loglength_start), g_first/exp(loglength_start) )^2)

```

Noticeably, the added total GFP correlates more with the added volume (as expected assuming that fluctuation in division time are driven by fluctuations in growth rate) than with the division time (as predicted assuming a constant production rate):

```{r}
ggplot(mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')),
       aes((time_div-time_birth)/60, g_last-g_first, col=condition)) +
  geom_point(size=.3, alpha=.5) +
  # geom_density2d(size=.5, alpha=.5) +
  expand_limits(x=0, y=0) + xlim(0, 300) +
  labs(x='division time (min)', y='added total GFP') +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))
# ggsave('Rplot.pdf', width=4, height=4.5)

mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')) %>% 
  filter((time_div-time_birth)/60<300) %>% 
  group_by(condition) %>% 
  summarise(r2=corPearson((time_div-time_birth)/60, g_last-g_first)^2)

ggplot(mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')),
       aes(exp(loglength_end)-exp(loglength_start), g_last-g_first, col=condition)) +
  geom_point(size=.3, alpha=.5) +
  # geom_density2d(size=.5, alpha=.5) +
  expand_limits(x=0, y=0) +
  labs(x='added volume', y='added total GFP') +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))
# ggsave('Rplot.pdf', width=4, height=4.5)


mycells %>% filter(condition %in% c('lactose', 'lactose_lowillum')) %>% 
  group_by(condition) %>% 
  summarise(r2=corPearson(exp(loglength_end)-exp(loglength_start), g_last-g_first )^2)

```


### Total GFP during the cell cycle


```{r}
myframes %>% 
  filter(!discard_top, condition=='lactose') %>% 
  group_by(date, pos, gl, id) %>% 
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>% 
  (function(.df)
    ggplot(.df, aes((time_sec-start_time)/60, gfp_nb)) +
  geom_path(aes(col=interaction(date, pos), group=cell), size=.5, alpha=.1,
            data=.df %>% group_by(date, pos) %>% slice(1:1e4)) +
  stat_summary(fun.data=mean_sdl, geom="point") +
  xlim(0, 150) + 
  scale_y_continuous(trans='log2') )
# expand_limits(y=0)

```

It's tempting to shift all traces so that they start at the average GFP level at birth. However, it doesn't change the mean. Let's write $g_i(t)$ the total GFP of cell i at time t after division, and $s_i(t)$ its shifted counterpart: $s_i(t) = g_i(t) - g_i(0) + <g(0)>$. Due to the linearity of the mean operator, $<s(t)> = <g(t)> - <g(0)> + <g(0)> = <g(t)>$



```{r eval=FALSE}
# why is it not working numerically?!?

lacgfp_birth_avg <- myframes %>% 
  filter(!discard_top, condition=='lactose') %>% 
  group_by(date, pos, gl, id) %>% 
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>% 
  filter(time_sec==first(time_sec)) %>% 
  .[['gfp_nb']] %>% mean


myframes %>% 
  filter(!discard_top, condition=='lactose') %>% 
  group_by(date, pos, gl, id) %>% 
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>% 
  arrange(time_sec) %>%
  mutate(gfp_aligned=gfp_nb-first(gfp_nb)+lacgfp_birth_avg) %>% 
ggplot(aes((time_sec-start_time)/60, gfp_aligned)) +
  # geom_path(aes(col=interaction(date, pos), group=cell), size=.5, alpha=.1) +
  stat_summary(aes(col='aligned'), fun.y=mean, geom="point") +
  stat_summary(aes(y=gfp_nb, col='raw'), fun.y=mean, geom="point") +
  xlim(0, 150) +
  scale_y_continuous(trans='log2') +
  coord_cartesian(ylim=c(4000, 8500))

```

The total GFP doesn't increase linearly with cell volume!

```{r}
myframes %>% 
  filter(!discard_top, condition=='lactose') %>% 
  group_by(date, pos, gl, id) %>% 
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>%   
  # group_by(date, pos) %>% slice(1:1e4) %>% 
ggplot(aes(y=gfp_nb)) +
  # geom_path(aes(col=interaction(date, pos), group=cell), size=.5, alpha=.1) +
  stat_summary(aes(x=mycut(length_um, seq(0, 5,.1)), col='raw'), alpha=0.5,
               fun.data=mean_sdl, geom="pointrange") +
  stat_summary(aes(x=mycut(length_predict, seq(0, 5,.1)), col='fit'), alpha=0.5,
               fun.data=mean_sdl, geom="pointrange") +
  stat_smooth(aes(length_um, col='raw'), method='lm') +
  stat_smooth(aes(length_predict, col='fit'), method='lm') +
  xlim(1.5, 3.7) + expand_limits(y=0) + labs(x='length (µm)', y='total GFP fluorescence (molecules)', col='length') +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))
  # scale_y_continuous(trans='log2')

```

Total GFP relative to the level at birth over the cell cycle:

```{r}
myframes %>% 
  filter(!discard_top, !discard_start, condition=='lactose', gfp_nb<2e4) %>% 
  group_by(date, pos) %>% slice(1:1e4) %>% 
  group_by(date, pos, gl, id) %>% arrange(time_sec) %>% mutate(gfp_rel=gfp_nb/first(gfp_nb)) %>% 
ggplot(aes(cell_cycle, gfp_rel)) +
  geom_path(aes(col=interaction(date, pos), group=cell), size=.5, alpha=.1) + 
  stat_summary(aes(mycut(cell_cycle, seq(0,1,.01))), fun.data=mean_sdl, geom="pointrange") +
  # expand_limits(y=0) +
  scale_y_continuous(trans='log2')


```


### GFP concentration during the cell cycle

```{r}
myframes %>% 
  filter(!discard_top, condition=='lactose') %>% 
  group_by(date, pos, gl, id) %>% 
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>% 
ggplot(aes((time_sec-start_time)/60)) +
  stat_summary(aes(y=gfp_nb/length_um, col='raw'), alpha=0.5, fun.data=mean_sdl, geom="pointrange") +
  stat_summary(aes(y=gfp_nb/length_predict, col='fit'), alpha=0.5, fun.data=mean_sdl, geom="pointrange") +
  xlim(0, 150) + expand_limits(y=0) +
  labs(y='GFP concentration (molecules/µm)', col='length')

# myframes %>% 
#   filter(!discard_top, !discard_start, condition=='lactose', gfp_nb<2e4) %>% 
#   group_by(date, pos, gl, id) %>% arrange(time_sec) %>% 
#   mutate(gfp_conc_relr1=gfp_nb/length_um*first(length_um)/first(gfp_nb),
#          gfp_conc_relrm=gfp_nb/length_um*mean(length_um)/mean(gfp_nb),
#          gfp_conc_relp1=gfp_nb/length_predict*first(length_predict)/first(gfp_nb),
#          gfp_conc_relpm=gfp_nb/length_predict*mean(length_predict)/mean(gfp_nb)) %>% 
# ggplot(aes((time_sec-start_time)/60)) +
#   stat_summary(aes(y=gfp_conc_relr1, col='raw_first'), alpha=0.5, fun.data=mean_sdl, geom="pointrange") +
#   stat_summary(aes(y=gfp_conc_relrm, col='fit_first'), alpha=0.5, fun.data=mean_sdl, geom="pointrange") +
#   stat_summary(aes(y=gfp_conc_relp1, col='raw_mean'), alpha=0.5, fun.data=mean_sdl, geom="pointrange") +
#   stat_summary(aes(y=gfp_conc_relpm, col='fit_mean'), alpha=0.5, fun.data=mean_sdl, geom="pointrange") +
#   xlim(0, 200) + expand_limits(y=0) +
#   labs(y='relative GFP concentration', col='length_norm')

myframes %>% 
  filter(!discard_top, condition=='lactose') %>% 
  group_by(date, pos, gl, id) %>% 
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>%   
  mutate(gfp_conc_relr1=gfp_nb/length_um*first(length_um)/first(gfp_nb),
         gfp_conc_relrm=gfp_nb/length_um*mean(length_um)/mean(gfp_nb),
         gfp_conc_relp1=gfp_nb/length_predict*first(length_predict)/first(gfp_nb),
         gfp_conc_relpm=gfp_nb/length_predict*mean(length_predict)/mean(gfp_nb)) %>% 
ggplot(aes((time_sec-start_time)/60)) +
  stat_summary(aes(y=gfp_conc_relr1, col='raw_first'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  stat_summary(aes(y=gfp_conc_relrm, col='raw_mean'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  stat_summary(aes(y=gfp_conc_relp1, col='fit_first'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  stat_summary(aes(y=gfp_conc_relpm, col='fit_mean'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  xlim(0, 150) + coord_cartesian(ylim=c(0.75, 1.1)) +
  labs(y='relative GFP concentration', col='length_norm')

myframes %>% 
  filter(!discard_top, condition=='lactose') %>% 
  group_by(date, pos, gl, id) %>% 
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>%   
  mutate(gfp_conc_relr1=gfp_nb/length_um*first(length_um)/first(gfp_nb),
         gfp_conc_relrm=gfp_nb/length_um*mean(length_um)/mean(gfp_nb),
         gfp_conc_relp1=gfp_nb/length_predict*first(length_predict)/first(gfp_nb),
         gfp_conc_relpm=gfp_nb/length_predict*mean(length_predict)/mean(gfp_nb)) %>% 
ggplot(aes(mycut(cell_cycle, seq(0, 1, length.out=41)))) +
  stat_summary(aes(y=gfp_conc_relr1, col='raw_first'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  stat_summary(aes(y=gfp_conc_relrm, col='raw_mean'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  stat_summary(aes(y=gfp_conc_relp1, col='fit_first'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  stat_summary(aes(y=gfp_conc_relpm, col='fit_mean'), alpha=0.5, fun.data=mean_sdl, geom="point") +
  coord_cartesian(ylim=c(0.85, 1.1)) +
  labs(x='cell cycle', y='relative GFP concentration', col='length_norm')

```


```{r, eval=FALSE}
myframes %>% filter(!discard_top, !discard_start, condition=='lactose', gfp_nb<2e4) %>% 
  mutate(time_cell=time_sec-start_time) %>% 
  group_by(date, pos, time_cell) %>% 
  summarise(mean=mean(gfp_nb/length_um), sd=sd(gfp_nb/length_um), cov=sd/mean) %>% 
  gather(variable, value, -date, -pos, -time_cell) %>% 
ggplot(aes(time_cell, value, col=interaction(date, pos))) + 
  facet_grid(variable~., scales='free_y') + 
  geom_path() +
  xlim(0, 5e3)
```


Autocorrelation of concentration for mother cells:

```{r}
myframes %>% filter(!discard_top, !discard_start, condition=='lactose',
                    cell_num_in_lane==total_cell_in_lane) %>% 
  # remove 2 outliers lineages
  group_by(date, pos, gl) %>% filter(all(gfp_nb/length_um>1200)) %>% 
  ggplot(aes(time_sec-2*3600, gfp_nb/length_um)) +
  geom_line(aes(col=interaction(date, pos, gl)), alpha=.25) +
  # stat_summary(fun.data=mean_sdl, geom="pointrange") +
  # stat_smooth(method='lm') +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_hours() +
  labs(y='GFP concentration\n(molecules/µm)') +
  expand_limits(y=0)
# ggsave('Rplot.pdf', width=8, height=2.5)

myframes %>% filter(!discard_top, !discard_start, condition=='lactose',
                    cell_num_in_lane==total_cell_in_lane) %>% 
  group_by(date, pos, gl) %>% 
  filter(all(gfp_nb/length_um>1200)) %>% 
  do((function(.df){
    # browser()
    .acf <- acf(.df$gfp_nb/.df$time_sec, lag.max=100, plot=FALSE)
    data.frame(lag=.acf$lag*dt, acf=.acf$acf)
  })(.)) %>% 
  ggplot(aes(lag, acf)) +
  geom_line(aes(col=interaction(date, pos, gl)), alpha=.25) +
  stat_summary(fun.y=mean, geom='line', size=1) +
  scale_colour_periodic_brewer(guide='none') +
  labs(x='lag (min)', y='autocorrelation')

myframes %>% filter(!discard_top, !discard_start, condition=='lactose',
                    cell_num_in_lane==total_cell_in_lane) %>% 
  group_by(date, pos, gl) %>% 
  filter(all(gfp_nb/length_um>1200)) %>% 
  do((function(.df){
    # browser()
    .acf <- acf(.df$gfp_nb/.df$time_sec, lag.max=100, plot=FALSE)
    data.frame(lag=.acf$lag*dt, acf=.acf$acf)
  })(.)) %>% 
  (function(.df) 
    ggplot(.df, aes(lag, log(acf))) +
     geom_line(aes(col=interaction(date, pos, gl)), alpha=.25) +
     # geom_errorbar(aes(ymin=log(acf-2*acf_sd), ymax=log(acf+2*acf_sd)),
     # data=.df %>% group_by(lag) %>% summarise(acf=mean(acf), acf_sd=sd(acf))) ) +
     geom_line(size=1, data=.df %>% group_by(lag) %>% summarise(acf=mean(acf)) ) +
     geom_smooth(method='lm', formula='y~x-1', lty='dashed',
                 data=.df %>% group_by(lag) %>% summarise(acf=mean(acf)) %>% filter(lag<50), fullrange=TRUE) +
     # scale_y_log10() +
     scale_colour_periodic_brewer(guide='none') +
     xlim(0, 100) + ylim(-5, 0) +
     labs(x='lag (min)', y='log(autocorrelation)')
  )


# myframes %>% filter(!discard_top, !discard_start, condition=='lactose',
#                     cell_num_in_lane==total_cell_in_lane) %>% 
#   group_by(date, pos, gl) %>% 
#   filter(all(gfp_nb/length_um>1200)) %>% 
#   do((function(.df){
#     browser()
#     .xs <- .df$gfp_nb/.df$time_sec
#     length(.xs) <- 500
#     .sp <- spectrum(.xs, plot=FALSE)
#     data.frame(freq=.sp$freq/dt, spec=.sp$spec)
#   })(.)) %>% 
#   (function(.df) {
#     ggplot(.df, aes(freq, spec)) +
#       geom_line(aes(col=interaction(date, pos, gl)), alpha=.25) +
#       stat_summary(fun.data=mean_sdl, geom="pointrange") +
#       scale_x_log10() + scale_y_log10() +
#       scale_colour_periodic_brewer(guide='none') 
#   })

```


### GFP production rate

The instantaneous production rate $dGFP/dt$ can be estimated by discrete derivative. The instantaneous GFP production relative to the proteome ($dGFP/dL$) is estimated using the length predicted from the expoenntial elongation fit ($L_f$). Noticeably, $dGFP/dL_f = 1/r \times 1/L dGFP/dt$ where $r$ is the cell elongation rate.

```{r}
myrates %>% filter(condition %in% 'lactose') %>% 
  group_by(cell) %>% filter(n()>10) %>% sample_n(3) %>% 
  ungroup() %>% 
  filter(between(islope_g_l, quantile(islope_g_l, 1e-4), quantile(islope_g_l, 1-1e-4))) %>% 
  mutate(islope_g_t_per_l = islope_g_time/length_predict,
         islope_g_t_per_l_std = (islope_g_t_per_l-mean(islope_g_t_per_l))/sd(islope_g_t_per_l),
         islope_g_l_std = (islope_g_l-mean(islope_g_l))/sd(islope_g_l),
         gfp_deriv_per_l = gfp_deriv/length_predict,
         gfp_deriv_per_l_std = (gfp_deriv_per_l-mean(gfp_deriv_per_l, na.rm=T))/sd(gfp_deriv_per_l, na.rm=T)) %>% 
ggplot(aes(y=..density..)) +
  geom_step_hist(aes(x=islope_g_t_per_l_std, col='1/L dGFP/dt'), binwidth=.1, position='identity') +
  geom_step_hist(aes(x=islope_g_l_std, col='dGFP/dL'), binwidth=.1, position='identity') +
  geom_step_hist(aes(x=gfp_deriv_per_l_std, col='1/L dGFP/dt\n(instantaneous)'), binwidth=.1, position='identity') +
  scale_y_log10() +
  xlim(-10, 10) + labs(x='z-value')

myrates %>% filter(condition %in% 'lactose') %>% 
  group_by(cell) %>% filter(n()>10) %>% sample_n(3) %>% 
  ungroup() %>% 
  filter(between(islope_g_l, quantile(islope_g_l, 1e-4), quantile(islope_g_l, 1-1e-4))) %>% 
  mutate(islope_g_t_per_l_cor = islope_g_time/length_predict / islope_ll_time,
         gfp_deriv_per_l_cor = gfp_deriv/length_predict / islope_ll_time) %>% 
ggplot(aes(y=..density..)) +
  xlim(-1e3, 2e4) +
  geom_step_hist(aes(x=islope_g_t_per_l_cor, col='1/L dGFP/dt'), position='identity') +
  geom_step_hist(aes(x=islope_g_l, col='dGFP/dL'), position='identity') +
  geom_step_hist(aes(x=gfp_deriv_per_l_cor, col='1/L dGFP/dt raw'), position='identity') +
  # scale_y_log10() +
   labs(x='value', col='variable')
  

myrates %>% filter(condition %in% 'lactose') %>% 
  group_by(cell) %>% filter(n()>10) %>% sample_n(3) %>% 
  with(cor(length_um, islope_ll_time)^2)


# myrates %>% filter(condition %in% 'lactose') %>% 
#   group_by(cell) %>% filter(n()>10) %>% sample_n(3) %>% 
# ggplot(aes(x=length_um, y=islope_ll_time)) +
# geom_point(alpha=0.1)
# 

```


Computed per sec and normalized per cell length.
In order to compare the distribution with a random population sampling (e.g. flow cytometry), we use a fixed number of measurements per cell (otherwise cells growing cells are overrepresented).

```{r}
myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose') %>% 
         group_by(cell) %>% filter(n()>10) %>% sample_n(3) %>% 
ggplot(aes(x=gfp_deriv/length_predict, y=..density..)) +
  geom_histogram(binwidth=.1) +
  geom_step_hist(aes(col=factor(date)), binwidth=.1, position='identity') 

last_plot() + scale_y_log10()


myframes %>% filter(!discard_top, !discard_start, condition %in% c('lactose', 'lactose_lowillum')) %>% 
         group_by(cell) %>% filter(n()>10) %>% sample_n(3) %>% 
ggplot(aes(x=gfp_deriv/length_predict, 1e3*..density..)) +
  geom_vline(xintercept=0, lty='dashed') +
  stat_bin(aes(fill=factor(condition)), binwidth=.1, position='identity', alpha=0.1, show_guide=FALSE) +
  geom_step_hist(aes(col=factor(condition)), binwidth=.1, position='identity') +
  scale_y_log10() + xlim(-3, 3) +
  labs(x='1/length dGFP/dt', y='density (x1000)', col='condition') +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))

```


Plot over the cell cycle in physical time unit:
NB: lacZ position 364kb; oriC position 3924kb
hence distance to origin = 4640 - (3924-364) = 1080kb
i.e. 47% of total replication path: 1080 / (4640/2)
NB: Ter sites at ≈1470, 3924-1470=2454kb vs 2185kb

```{r}
ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose'),
       aes(x=(time_sec-start_time)/60)) +
  # stat_smooth(aes(y=gfp_deriv/length_predict, col='predict')) +
  # stat_smooth(aes(y=gfp_deriv/length_um, col='raw')) +
  stat_summary(aes(y=gfp_deriv/length_predict, col='predict'), fun.y=mean, geom="point") +
  stat_summary(aes(y=gfp_deriv/length_um, col='raw'), fun.y=mean, geom="point") +
  xlim(0, 200) +
  expand_limits(y=0)

# ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose'),
#        aes(x=(time_sec-start_time)/60)) +
#   stat_summary(aes(y=gfp_deriv/length_predict, col='predict'), fun.data=mean_sdl, geom="pointrange") +
#   stat_summary(aes(y=gfp_deriv/length_um, col='raw'), fun.data=mean_sdl, geom="pointrange") +
#   xlim(0, 200)

```


Plot as a function of the cell cycle progression:

```{r}
ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose'),
       aes(x=mycut(cell_cycle, seq(0, 1, length.out=30)))) +
  # stat_smooth(aes(x=cell_cycle, y=gfp_deriv/length_predict, col='predict')) +
  # stat_smooth(aes(x=cell_cycle, y=gfp_deriv/length_um, col='raw')) +
  stat_summary(aes(y=gfp_deriv/length_predict, col='predict'), fun.y=mean, geom="point") +
  stat_summary(aes(y=gfp_deriv/length_um, col='raw'), fun.y=mean, geom="point") +
  labs(x="cell cycle") +
  expand_limits(y=0)

ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose'),
       aes(x=mycut(cell_cycle, seq(0, 1, length.out=30)))) +
  stat_summary(aes(y=gfp_deriv/length_predict, col='predict'), fun.data=mean_sdl, geom="pointrange") +
  stat_summary(aes(y=gfp_deriv/length_um, col='raw'), fun.data=mean_sdl, geom="pointrange") +
  labs(x="cell cycle") +
  expand_limits(y=0)

```


Plot similar to Walker, Nghe & Tans 2016

```{r}
ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose'),
       aes(x=mycut(cell_cycle, seq(0, 1, length.out=30)))) +
  stat_summary(aes(y=gfp_deriv), fun.y=mean, geom="point") +
  labs(x="cell cycle") +
  expand_limits(y=0)

```

Matteo suggests that tracks should be aligned by their estimated time at replication. phase C+D lasts ca. 60 min, hence extrapolate lr the average length 40 min before division (60 - 20 for 1/2 replication because locus at 47%). For each cell take the time at which the length is lr as the time origin.

```{r}
dt_lac <- filter(mycells, condition=='lactose')$logl_time_slope %>% 
  (function(.x) log(2)/.x) %>% mean

llr <- semi_join(myframes, filter(mycells, condition=='lactose')) %>% 
  mutate(t_todiv=end_time-time_sec) %>% 
  group_by(t_todiv) %>% summarise(llength_um=mean(log(length_um))) %>% 
  lm(llength_um~t_todiv, data=.) %>% 
  predict(data.frame(t_todiv=dt_lac-40*60))
  
myframes %>% 
  semi_join(filter(mycells, condition=='lactose'), by='cell') %>% 
  group_by(cell) %>% 
  mutate(repl_idx=which.min(abs(log(length_predict)-llr)),
         time_repl=time_sec[repl_idx]) %>% 
ggplot(aes(x=(time_sec-time_repl)/60)) +
  stat_summary(aes(y=gfp_deriv), fun.y=mean, geom="point") +
  labs(x="time after GFP locus replication (min)") +
  xlim(-70, 60) + expand_limits(y=0)

myframes %>% 
  semi_join(filter(mycells, condition=='lactose'), by='cell') %>% 
  group_by(cell) %>% 
  mutate(repl_idx=which.min(abs(log(length_predict)-llr)),
         time_repl=time_sec[repl_idx], time_sync=time_sec-time_repl) %>% 
  ungroup %>% group_by(time_sync) %>% 
  summarise(n=sum(!is.na(gfp_deriv)), gfp_deriv=mean(gfp_deriv, na.rm=TRUE)) %>% 
  filter(between(time_sync/60, -70, 60)) %>% 
ggplot(aes(x=time_sync/60)) +
  geom_point(aes(y=gfp_deriv, alpha=n)) +
  # stat_summary(aes(y=gfp_deriv), fun.y=mean, geom="point") +
  labs(x="time after GFP locus replication (min)") +
  expand_limits(y=0)


```


Erik has different expectation: the instantaneous production relative to the whole proteome should be 

```{r}
myframes %>% 
  semi_join(filter(mycells, condition=='lactose'), by='cell') %>% 
  left_join(myrates %>% select(cell, time_sec, islope_ll_time, islope_g_l)) %>% 
  group_by(cell) %>% 
  mutate(repl_idx=which.min(abs(log(length_predict)-llr)),
         time_repl=time_sec[repl_idx], time_sync=time_sec-time_repl) %>% 
  ungroup %>% group_by(time_sync) %>% 
  summarise(n=sum(!is.na(gfp_deriv)), islope_g_l=mean(islope_g_l, na.rm=TRUE),
            gfp_deriv_per_length=mean(gfp_deriv/length_predict, na.rm=TRUE)) %>% 
  filter(between(time_sync/60, -45, 60)) %>% 
ggplot(aes(x=time_sync/60)) +
  # geom_point(aes(y= gfp_deriv_per_length, alpha=n)) +
  geom_point(aes(y= islope_g_l, alpha=n)) +
  # stat_summary(aes(y=gfp_deriv), fun.y=mean, geom="point") +
  labs(x="time after GFP locus replication (min)") +
  expand_limits(y=0)

```


```{r eval=FALSE}
ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose'),
       aes(x=mycut(length_predict, seq(0,10,.1)))) +
  # stat_smooth(aes(x=cell_cycle, y=gfp_deriv/length_predict, col='predict')) +
  # stat_smooth(aes(x=cell_cycle, y=gfp_deriv/length_um, col='raw')) +
  stat_summary(aes(y=gfp_deriv), fun.y=mean, geom="point") +
  labs(x="length (um)") +
  xlim(0, 4) +
  expand_limits(y=0)

ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% 'lactose'),
       aes(x=mycut(cell_cycle, seq(0, 1, length.out=30)))) +
  # stat_smooth(aes(x=cell_cycle, y=gfp_deriv/length_predict, col='predict')) +
  # stat_smooth(aes(x=cell_cycle, y=gfp_deriv/length_um, col='raw')) +
  stat_summary(aes(y=gfp_deriv), fun.y=mean, geom="point") +
  labs(x="cell cycle") +
  expand_limits(y=0)

```


Autocorrelation of production for mother cells:

```{r}
myframes %>% filter(!discard_top, !discard_start, condition=='lactose',
                    cell_num_in_lane==total_cell_in_lane) %>% 
  ggplot() +
  geom_line(aes(time_sec, gfp_deriv/length_predict, col=interaction(date, pos, gl)), alpha=.05) +
  scale_colour_periodic_brewer(guide='none')

myframes %>% filter(!discard_top, !discard_start, condition=='lactose',
                    cell_num_in_lane==total_cell_in_lane) %>% 
  group_by(date, pos, gl) %>% 
  do((function(.df){
    # browser()
    .acf <- acf(.df$gfp_deriv/.df$length_predict, lag.max=100, na.action=na.pass, plot=FALSE)
    data.frame(lag=.acf$lag*dt, acf=.acf$acf)
    })(.)) %>% 
  # filter(acf<.5) %>% 
  ggplot(aes(lag, acf)) +
  geom_path(aes(col=interaction(date, pos, gl)), alpha=.25) +
  stat_summary(fun.data=mean_sdl, geom="pointrange") +
  scale_colour_periodic_brewer(guide='none') +
  xlim(0, 100) +
  labs(x='lag (min)', y='autocorrelation')
ggsave('Rplot.pdf', width=4, height=2.5)

last_plot() +
  scale_y_log10()

myframes %>% filter(!discard_top, !discard_start, condition=='lactose',
                    cell_num_in_lane==total_cell_in_lane) %>% 
  group_by(date, pos, gl) %>% 
  do((function(.df){
    # browser()
    .acf <- acf(.df$gfp_deriv/.df$length_predict, lag.max=100, na.action=na.pass, plot=FALSE)
    data.frame(lag=.acf$lag*dt, acf=.acf$acf)
  })(.)) %>% 
  (function(.df) 
    ggplot(.df, aes(lag, log(acf))) +
     geom_line(aes(col=interaction(date, pos, gl)), alpha=.25) +
     # geom_errorbar(aes(ymin=log(acf-2*acf_sd), ymax=log(acf+2*acf_sd)),
     # data=.df %>% group_by(lag) %>% summarise(acf=mean(acf), acf_sd=sd(acf))) ) +
     geom_line(size=1, data=.df %>% group_by(lag) %>% summarise(acf=mean(acf)) ) +
     geom_smooth(method='lm', formula='y~x-1', lty='dashed',
                 data=.df %>% group_by(lag) %>% summarise(acf=mean(acf)) %>% filter(lag<50), fullrange=TRUE) +
     # scale_y_log10() +
     scale_colour_periodic_brewer(guide='none') +
     xlim(0, 100) + ylim(-7, 0) +
     labs(x='lag (min)', y='log(autocorrelation)')
  )


```


### Inheritance of GFP dynamics

Correlation as a function of genealogical relationship:

```{r}

mypairs_lactose <- mycells %>% filter(condition %in% 'lactose') %>% 
  # group_by(gl_id) %>%
  partition(gl_id, cluster=mycluster %>% cluster_assign_func(genealogy_relationship) %>% cluster_assign_func(genealogy_ontology)) %>%
  # compute all pairs and their relationship
  do((function(.df) {
    # browser()
    if (dim(.df)[1]<2) 
      return(data.frame())
    return( combn(.df$genealogy, 2, simplify=FALSE) %>% 
      lapply(function(.x) as.data.frame(genealogy_relationship(.x), stringsAsFactors=FALSE)) %>% 
      do.call(rbind, .) )
  })(.)) %>% 
  collect() %>% 
  rename(div_upstream = div_min, div_downstream = div_max) %>% 
  group_by(div_upstream, div_downstream) %>% 
  mutate(
    genealogy_upstream = ifelse(div_1<div_2, genealogy_1, genealogy_2),
    genealogy_downstream = ifelse(div_1<div_2, genealogy_2, genealogy_1),
    div_1=NULL, div_2=NULL, genealogy_1=NULL, genealogy_2=NULL)


mypairs_lactose %>% 
  left_join(mycells %>% ungroup %>% select(-date, -pos, -gl) %>% 
              setNames(., paste(names(.), "upstream", sep="_")) %>% rename(gl_id=gl_id_upstream) ) %>% 
  left_join(mycells %>% ungroup %>% select(-date, -pos, -gl) %>% 
              setNames(., paste(names(.), "downstream", sep="_")) %>% rename(gl_id=gl_id_downstream) ) %>% 
ggplot(aes((g_last_upstream-g_first_upstream) / (exp(loglength_end_upstream)-exp(loglength_start_upstream)), 
           (g_last_downstream-g_first_downstream) / (exp(loglength_end_downstream)-exp(loglength_start_downstream)), col=factor(rel))) +
  geom_point(alpha=.5, size=.5) +
  expand_limits(x=0, y=0)


mypairs_lactose %>% 
  left_join(mycells %>% ungroup %>% select(-date, -pos, -gl) %>% 
              setNames(., paste(names(.), "upstream", sep="_")) %>% rename(gl_id=gl_id_upstream) ) %>% 
  left_join(mycells %>% ungroup %>% select(-date, -pos, -gl) %>% 
              setNames(., paste(names(.), "downstream", sep="_")) %>% rename(gl_id=gl_id_downstream) ) %>% 
  group_by(rel, div_upstream, div_downstream) %>% 
  summarise(r2=cor((g_last_upstream-g_first_upstream) / (exp(loglength_end_upstream)-exp(loglength_start_upstream)), 
                   (g_last_downstream-g_first_downstream) / (exp(loglength_end_downstream)-exp(loglength_start_downstream)), 
                   use="complete.obs", method="pearson")^2, n=n()) %>% 
  (function(.df) ggplot(.df, aes(div_upstream, div_downstream)) +
     # facet_grid(.~switch_idx) +
     geom_tile(aes(fill=r2), stat='identity', show.legend=FALSE) +
     geom_text(aes(label=sprintf("%s\nr2 = %.3f", rel, r2))) +
     geom_text(aes(y=div_downstream-.4, label=sprintf("(n = %d)", n))) +
     scale_fill_gradient(high='red', low='lightblue') +
     scale_x_continuous(breaks=0:10, expand=c(0,0)) + scale_y_continuous(trans="reverse", breaks=0:10, expand=c(0,0)) +
     expand_limits(fill=0) + coord_fixed() +
     labs(title='added GFP / added volume', x='divs since common ancestor (cell 1)', y='div since common ancestor (cell 2)')
  )

```


```{r}
# keep only the relevant rows (for faster filtering)
myframes_lac_pairs <- myframes %>% ungroup %>% 
  semi_join(filter(mycells, condition %in% 'lactose'), by='cell') # all rows in a that have a match in b

tmp <- mypairs_lactose %>% 
  filter(div_upstream<3, div_downstream<3) %>%
  rowwise() %>% # "group by" each row
  partition(gl_id, rel, div_upstream, div_downstream, genealogy_upstream, genealogy_downstream, 
            cluster=mycluster %>% cluster_assign_obj(myframes_lac_pairs)) %>% 
  do((function(.df) {
    # browser()
    .dfu <- filter(myframes_lac_pairs, gl_id==.df$gl_id, genealogy==.df$genealogy_upstream)
    .dfd <- filter(myframes_lac_pairs, gl_id==.df$gl_id, genealogy==.df$genealogy_downstream)
    .lmin <- min(dim(.dfu)[1], dim(.dfd)[1])
    rbind(data.frame(var="gfp_nb_correl", val=cor(.dfu$gfp_nb[1:.lmin], .dfd$gfp_nb[1:.lmin])),
          data.frame(var="gfp_nb_covar", val=cov(.dfu$gfp_nb[1:.lmin], .dfd$gfp_nb[1:.lmin])) )
  })(.)) %>% 
  collect()

ggplot(filter(tmp, var=='gfp_nb_correl'), aes(val)) +
  facet_grid(div_downstream~div_upstream) +
  # geom_step_hist(aes(y=..density..)) +
  stat_ecdf() +
  scale_y_log10()

ggplot(filter(tmp, var=='gfp_nb_correl'), aes(val)) +
  stat_ecdf(aes(col=interaction(div_downstream, div_upstream))) +
  scale_y_log10()


ggplot(filter(tmp, var=='gfp_nb_covar'), aes(val)) +
  facet_grid(div_downstream~div_upstream) +
  # geom_step_hist(aes(y=..density..)) +
  stat_ecdf(aes(y=1-..y..)) +
  scale_y_log10()

ggplot(filter(tmp, var=='gfp_nb_covar'), aes(val)) +
  stat_ecdf(aes(y=1-..y.., col=interaction(div_downstream, div_upstream))) +
  scale_y_log10()

```



<!-- ## Instantaneous rates 

Let's check whether an exponential or linear model is better to describe the instantaneous change: 
-->

```{r eval=FALSE}
i <- 16

myrates %>% 
  filter(condition=='lactose') %>% 
  ungroup %>%  filter(cell==nth(unique(cell), i)) %>% 
  select(cell, time_sec, gfp_nb, ir2_g_time, ir2_lg_time) %>% 
  gather(var, value, -cell, -time_sec) %>% 
  mutate(type=ifelse(var=='ir2_lg_time', 'exponential', 'linear'),
         var=ifelse(var!='gfp_nb', 'r2', var)) %>% # todo: rather use a regex
ggplot() +
  facet_grid(var~., scales='free_y') +
  geom_point(aes(time_sec, value, col=cell)) +
  geom_path(aes(time_sec, value, col=cell, linetype=type)) +
  geom_rug(aes(time_sec))

```

