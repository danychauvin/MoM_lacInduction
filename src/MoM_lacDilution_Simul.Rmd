---
title: "Untitled"
output: html_document
---

# Population lags from distribution of single-cell lags

```{r}
gc_sim_params = list(lbd_1 = 1/(49*60), # in sec (coarse estimation from pop growth curves)
                     lbd_2 = 1/(58*60),
                     N_max = 1e9,
                     dilution = 1600,
                     F_sw = 1/4, # fraction of final OD at which the switch occurs
                     gr_lags = 0 # no lag (replace with a vector of lags to specify a distribution)
                     )

simul_gc <- function(.pars, .n_quantiles=101, .t_step=60) {
  # browser()
  t_sw <- log(.pars$dilution  * .pars$F_sw) / log(2) / .pars$lbd_1
  t_max <- t_sw + log(.pars$dilution  * (1-.pars$F_sw)) / log(2) / .pars$lbd_2 + 
    max(.pars$gr_lags[is.finite(.pars$gr_lags)])
  .gcs <- tibble(k=seq(0, 1, length.out=.n_quantiles)) %>% mutate(lag=quantile(.pars$gr_lags, k, na.rm=TRUE)) %>% 
    rowwise() %>% mutate(data=map(lag, function(.l) tibble(t=seq(t_sw, t_max, .t_step)) %>% 
                                    mutate(n_k=ifelse(t-t_sw>.l, 2^(.pars$lbd_2*(t-t_sw-.l)), 1))
      ))
  .gc <- tibble(t=seq(0, t_sw, .t_step)) %>% 
    mutate(n=.pars$N_max/.pars$dilution * 2^(.pars$lbd_1*t)) %>% 
    bind_rows(.gcs %>% unnest() %>% group_by(t) %>% 
                summarise(n=sum(n_k)/length(n_k) * .pars$N_max*.pars$F_sw)) %>% 
    mutate(t=t-t_sw)
}

# gc_sim_params %>%
#   modify_at("gr_lags", ~
#             mycells_switching %>% ungroup() %>%
#               filter(!date %in% discarded_dates) %>%
#               filter(!discard_arrested) %>%
#               filter(str_detect(condition, '^switch_[0-9]+h$')) %>%
#               filter(switch_idx==1) %>%
#               mutate(growth_lag=ifelse(growth_lag>240*60, Inf, growth_lag) ) %>%
#               pull(growth_lag)
#             # ggplot(aes(growth_lag/60, y=..density..)) +
#             # stat_density(adjust = 1/1.2) +
#             # geom_freqpoly(binwidth=3, col='red') +
#             # NULL) %>%
#   ) %>%
#   simul_gc() %>%
#   filter(n<2e9) %>%
#   ggplot(aes(t, n)) +
#   geom_line() +
#   scale_x_hours(4) +
#   scale_y_log10() +
#   NULL

```

```{r}
bind_rows(  
  gc_sim_params %>% 
    modify_at("gr_lags", ~0) %>% 
    simul_gc() %>% 
    mutate(type='no lag'),
  gc_sim_params %>% 
    modify_at("gr_lags", ~
                mycells_switching %>% ungroup() %>% 
                filter(!date %in% discarded_dates) %>%
                filter(!discard_arrested) %>% 
                filter(str_detect(condition, '^switch_[0-9]+h$')) %>%
                filter(switch_idx==1) %>%
                mutate(growth_lag=ifelse(growth_lag>240*60, Inf, growth_lag) ) %>% 
                pull(growth_lag) 
    ) %>% 
    simul_gc() %>% 
    mutate(type='glu > lac'),
  gc_sim_params %>% 
    modify_at("gr_lags", ~
                mycells_switching %>% ungroup() %>% 
                filter(!date %in% discarded_dates) %>%
                filter(!discard_arrested) %>% 
                filter(str_detect(condition, 'switch_glcLac_lac')) %>%
                filter(switch_idx==1) %>%
                mutate(growth_lag=ifelse(growth_lag>240*60, Inf, growth_lag) ) %>% 
                pull(growth_lag) 
    ) %>% 
    simul_gc() %>% 
    mutate(type='glu+lac > lac'),
  gc_sim_params %>% 
    modify_at("gr_lags", ~
                mycells_switching %>% ungroup() %>% 
                filter(!date %in% discarded_dates) %>%
                filter(!discard_arrested) %>% 
                filter(str_detect(condition, 'switch_glcLac_lac')) %>%
                filter(switch_idx==1, growth_lag<50*60) %>%
                mutate(growth_lag=ifelse(growth_lag>240*60, Inf, growth_lag) ) %>% 
                pull(growth_lag) 
    ) %>% 
    simul_gc() %>% 
    mutate(type='all short'),
) %>% 
  mutate(type=fct_relevel(type, 'no lag')) %>% 
  filter(between(n, 8e7, 1.2e9)) %>%
  ggplot(aes(t, n, col=type)) +
  geom_line() +
  # scale_x_continuous(breaks=scales::pretty_breaks(), trans=scales::hms_trans()) +
  scale_x_hours(2) +
  scale_y_log10() +
  coord_cartesian(ylim=c(1e8, 1e9)) +
  # theme_cowplot() +
  NULL

```


# LacI expression & single-cell lags for cells growing in the mother machine

Cai, *et al.* 2006 reports for the number of LacZ molecules per cells (inferred from change in hydrolysis rate of FDG)
in microfluidic chambers with M9 + 0.5% glucose + a.a. + vitamins (doubling time ≈ 145 ± 10 min)
NB: does the slow growth come from phototoxicity? from surface activation without passivation?
- a = 0.11 ± 0.03 bursts per cell cycle (exponential distribution)
- b = 5 ± 2 enzymes, or 20 ± 8 monomers per burst
with P(n) = c exp(n/b)

Yu, *et al.* 2006 reports for the number of Tsr-Venus expressed from the repressed lac promoter (lacZ locus)
on agarose pad with M9 medium, doubling time ≈ 55 ± 10 min
- burst size follows a geometric distribution with p=0.8 ± 0.1 (i.e. an average of 4.2 ± 0.5 molecules per burst)
- number of bursts per cell cycle follows a Poisson distribution with mean = 1.2
- each gene expression burst lasts 3 to 15 min

Ullman, *et al.* 2013 reports for the number of Tsr-Venus expressed from the repressed lac promoter (lacY locus)
microfluidics with M9 + 0.4% glucose + a.a., doubling time is 25 – 32 min
- average burst size of 1.7 ± 0.1 molecules per burst (they conclude that LacY has 3x lower translation rate than LacZ, but not info on the distribution).



```{r}
library(future)
library(furrr)
plan(multiprocess,
     workers=min(30, availableCores()-1))


mysim_params <- list(dt = 3, # in mins
                     random_seed = 1,
                     top_max=30, 
                     grs = mycells_constant %>% filter(condition=='glucose') %>% pull(alpha) %>% `*`(60),
                     dls = mycells_constant %>% filter(condition=='glucose') %>% with(l_div-l_birth),
                     l_births = mycells_constant %>% filter(condition=='glucose') %>% pull(l_birth),
                     burst_rate = 1 / (100/.7), # per min
                     burst_mean = 1.5) # geom distrib
# burst_sd=4)

sim_make_cells <- function(id=NA, l_birth=NA, gr=NA, dl=NA, t_birth=NULL,
                          pos=NA, l=NA, lacz=NA, t_burst=NA, 
                          t=mysim_t) {
  # if (t>0) browser()
  # l <- ifelse(is.na(l), l_birth, l)
  # l <- l_birth * (1 + exp(gr * (t-t_birth)) )
  if (is.null(t_birth)) t_birth <- t - log(l)-log(l_birth) / gr
  t_div <- t + log((l_birth+dl)/l) / gr
  data_frame(id=as.character(id), t_birth=t_birth, l_birth=l_birth, gr=gr, dl=dl, t_div=t_div,
             pos=pos, l=l, lacz=lacz, t_burst=t_burst, n_bursts=0)
}

sim_grow <-  function(cells, dt=mysim_params$dt) {
  cells$l <- cells$l * exp(cells$gr * dt)
  cells
}

sim_burst <- function(cells, t, b_mean=mysim_params$burst_mean, b_rate=mysim_params$burst_rate, reset=FALSE) {
  # browser()
  n_bursts <- if (reset) 0 else cells$n_bursts
  burst_cells <- cells$t_burst < t  &  cells$t_burst < cells$t_div
  while (any(burst_cells)) {
    n_bursts <- n_bursts + burst_cells
    cells$lacz[burst_cells] <- cells$lacz[burst_cells] + rgeom(sum(burst_cells), 1/b_mean)
    cells$t_burst[burst_cells] <- cells$t_burst[burst_cells] + rexp(sum(burst_cells), b_rate)
    burst_cells <- cells$t_burst < t  &  cells$t_burst < cells$t_div
  }
  cells$n_bursts <- n_bursts
  cells
}

sim_divide <- function(cells, t, grs=mysim_params$grs, dls=mysim_params$dls, 
                       b_mean=mysim_params$burst_mean, b_rate=mysim_params$burst_rate) {
# the existing cell becomes the bottom sister while a new cell is created for the other sister
# one assumes that the burst probability is per lac promoter and that the new promoter is created at birth
# hence a new indep waiting time is drawn for the newborn sister while the existing one is kept for the existing sister
  div_cells <- cells$t_div < t
  if (!any(div_cells)) return(cells)
  
  # browser()
  lacz_parents <- cells$lacz
  lacz_newborn <- Vectorize(function(size) rbinom(1, size=size, 0.5), 'size')(lacz_parents[div_cells])
  l_div <- cells$l_birth + cells$dl

  # update positions of existing cells
  cells$pos <- cells$pos + cumsum(lag(div_cells, default=0))
  
  # create newborn sister
  newborns <- sim_make_cells(id = paste0(cells$id[div_cells], 'T'), 
                             t_birth = cells$t_div[div_cells], l_birth=l_div[div_cells]/2, 
                             gr = quantile(grs, runif(sum(div_cells)) ), 
                             dl = quantile(dls, runif(sum(div_cells)) ),
                             pos = 1 + cells$pos[div_cells], 
                             l = l_div[div_cells]/2 * exp(cells$gr[div_cells] * (t-cells$t_div[div_cells])), 
                             lacz = lacz_newborn, 
                             t_burst = cells$t_div[div_cells] + rexp(sum(div_cells), b_rate), 
                             t=t)
  
  # existing sisters
  cells$id[div_cells] <- paste0(cells$id[div_cells], 'B')
  
  cells$l_birth[div_cells] <- l_div[div_cells]/2
  cells$t_birth[div_cells] <- cells$t_div[div_cells]
  cells$gr[div_cells] <- quantile(grs, runif(sum(div_cells)) ) 
  cells$dl[div_cells] <- quantile(dls, runif(sum(div_cells)) )
  cells$t_div[div_cells] <- cells$t_birth[div_cells] +
    log((cells$l_birth[div_cells]+cells$dl[div_cells])/cells$l_birth[div_cells]) / cells$gr[div_cells]
  
  cells$l[div_cells] <- cells$l_birth[div_cells] * exp(cells$gr[div_cells] * (t-cells$t_birth[div_cells]))
  cells$lacz[div_cells] <- lacz_parents[div_cells] - lacz_newborn
  # t_burst stays untouched
  
  cells <- rbind(cells, newborns)
  cells[order(cells$pos), ]
}

sim_exit <- function(cells, top_max=mysim_params$top_max) {
  cells <- cells[order(cells$pos), ]
  tops <- cumsum(cells$l)
  cells[tops < top_max, ]
}

sim_lineage <- function(n_inds, t_max=1000, sim_params=mysim_params) {
  # browser()
  # init
  sim_frames <- list()
    # in order to guarantee that all are born before t=0 and divide after t=0
    # cells are initialised with a l_birth, dl and gr and a current length (uniform sampling in [0, dl])
    # the corresponding t_birth and t_div are computed assuming exp elongation
    l_births <- quantile(sim_params$l_births, runif(n_inds))
    dls <- quantile(sim_params$dls, runif(n_inds))
    sim_cur <- sim_make_cells(id = seq(n_inds)-1, pos = seq(n_inds)-1, t = 0,
                   l_birth = l_births, gr = quantile(sim_params$grs, runif(n_inds)), dl = dls,
                   l = l_births + Vectorize(function(max) runif(1, max=max), 'max')(dls),
                   lacz = 0, 
                   # lacz = round(rexp(n_inds, 1/sim_params$burst_mean)), 
                   t_burst = rexp(n_inds, sim_params$burst_rate) )
  sim_frames[['0']] <- data.frame(t=0, sim_cur)
  
  # iterate
  for (sim_t in seq(sim_params$dt, t_max, sim_params$dt)) {
    # print(sim_t)
    sim_cur <- sim_grow(sim_cur)
    sim_cur <- sim_exit(sim_cur)
    sim_cur <- sim_burst(sim_cur, sim_t, reset=TRUE) # burst(s) before the division
    sim_cur <- sim_divide(sim_cur, sim_t)
    sim_cur <- sim_burst(sim_cur, sim_t) # burst(s) after the division
    
    sim_frames[[as.character(sim_t)]] <- data.frame(t=sim_t, sim_cur)
  }
  sim_frames
}

set.seed(mysim_params$random_seed)
mysim_frames <- tibble(gl=1:1000) %>% 
  mutate(data=future_map(gl, ~sim_lineage(6, t_max=2000) %>% bind_rows(), .progress=TRUE))

  # group_by(gl) %>%
  # partition(gl, cluster=mycluster %>% cluster_assign_obj(mysim_params) %>% 
  #             cluster_assign_func(sim_lineage, sim_make_cells, sim_grow, sim_exit,  sim_burst, sim_divide)
  #           ) %>%
  # do(sim_lineage(6, t_max=2000) %>% bind_rows()) %>% 
  # collect()
  

```

```{r}
mysim_frames %>% 
  sample_n(12) %>% 
  unnest() %>% 
  group_by(gl, t) %>% 
  arrange(gl, t, pos) %>% 
  mutate(bottom=cumsum(lag(l, default=0)) ) %>% 
  ggplot(aes(t, bottom+l/2, group=id)) +
  facet_wrap(~gl) +
  geom_rect(aes(xmin=t-1.5, xmax=t+1.5, ymin=bottom+.1, ymax=bottom+l-.1, fill=lacz>0)) +
  geom_line() +
  # scale_y_log10() + coord_cartesian(ylim=c(1, 30))
  # scale_fill_periodic_brewer(guide='none')
  coord_cartesian(xlim=c(0, 1000)) +
  NULL

mysim_frames %>% 
  unnest() %>% 
  ggplot(aes(n_bursts)) +
  geom_histogram() +
  scale_y_log10()

```

```{r}
mysim_frames %>% 
  sample_n(30) %>%
  unnest() %>% 
  group_by(gl, t) %>% 
  arrange(gl, t, pos) %>% 
  mutate(bottom=cumsum(lag(l, default=0)) ) %>% 
  ungroup() %>% 
  # filter(t>360) %>% 
  ggplot(aes(t*60, l)) +
  # facet_wrap(~gl) + 
  # geom_point(stroke=0, alpha=.2) +
  # stat_summary_bin(fun.data=mean_se,  binwidth=180*60, col='red') +
  stat_summary_bin(fun.data=mean_sdl, fun.args = list(mult=1),  binwidth=180*60) +
  # stat_summary_bin(fun.data=mean_se,  binwidth=180*60, geom='linerange', width=0, col='red') +
  # coord_cartesian(xlim=c(0, 1000)) +
  # expand_limits(y=0) +
  scale_x_hours() +
  labs(y="length (µm)") +
  NULL

```


```{r}
mysim_frames %>% 
  filter(gl<=30) %>% 
  group_by(gl, t) %>% 
  summarise(n_with=sum(lacz>0), n=n()) %>% 
  ggplot(aes(t, n_with/n)) +
  # geom_line(aes(col=factor(gl))) +
  stat_summary(fun.data=mean_se, geom="smooth", col='black') +
  scale_colour_periodic_brewer(guide='none') +
  coord_cartesian(ylim = c(0, 1))

mysim_frames %>% 
  filter(t>500) %>% 
  filter(gl<=30) %>% 
  slice(., seq(1, nrow(.), 30)) %>% 
  group_by(lacz) %>% summarise(n=n()) %>% 
  ungroup %>% mutate(p=n/sum(n)) %>% 
  ggplot() +
  geom_histogram(aes(lacz, p), stat="identity")


```

## Lag distribution

```{r}
mysim_cells_switching <- mysim_frames %>% 
  filter(t==max(t)) %>% 
  # compute lag based on lacz content + waiting time to next burst
  mutate(lag_200_nocomm = ifelse(lacz>0, 0, t_burst-t) + rnorm(n(), 33, 5)) %>% 
  # compute lag taking communication into account
  group_by(gl) %>%
  mutate(lag_200_glmin = min(lag_200_nocomm),
         lag_200 = pmin(lag_200_nocomm, lag_200_glmin+rnorm(n(), 70, 5)))

mysim_cells_switching %>% 
  group_by(gl) %>% 
  summarise(n=n(), n_with=sum(lacz>0)) %>% 
  ggplot(aes(n_with)) +
  geom_histogram(binwidth=1)

mysim_cells_switching %>% 
  # ggplot(aes(lag_200_nocomm)) +
  ggplot(aes(lag_200)) +
  geom_histogram(binwidth=3) +
  coord_cartesian(xlim=c(0, 240))

```


## Heritability

```{r}
mysim_pairs <- mysim_cells_switching %>% 
  rename(genealogy=id) %>% 
  group_by(gl) %>% 
  do((function(.df) {
    # browser()
    if (dim(.df)[1]<2) 
      return(data.frame())
    return( combn(.df$genealogy, 2, simplify=FALSE) %>% 
      lapply(function(.x) as.data.frame(genealogy_relationship(.x), stringsAsFactors=FALSE)) %>% 
      do.call(rbind, .) )
  })(.)) %>% 
  # rbind one df per variable type
  mutate(foo=1) %>% left_join(data.frame(foo=1, variable=c('lacz', 'lag_200_nocomm', 'lag_200'))) %>% select(-foo) %>% 
  # join variables of interest
  mutate(rel=factor(rel, levels=c("sisters", "cousins1", "cousins2", "niece"))) %>% 
  left_join(mysim_cells_switching %>% ungroup %>% rename(genealogy=id) %>% 
              gather(variable, value, lacz, lag_200_nocomm, lag_200) %>% 
              setNames(., paste(names(.), "1", sep="_")) %>% 
              rename(gl=gl_1, variable=variable_1) ) %>% 
  left_join(mysim_cells_switching %>% ungroup %>% rename(genealogy=id) %>% 
              gather(variable, value, lacz, lag_200_nocomm, lag_200) %>% 
              setNames(., paste(names(.), "2", sep="_")) %>% 
              rename(gl=gl_2, variable=variable_2) ) 
  
```

```{r}
mysim_pairs %>% ungroup %>% 
  filter(rel!='niece') %>% 
  filter(variable=='lag_200') %>%
  # create a symmetric scatter by duplicating
  group_by(variable) %>% 
  do((function(.df) bind_rows(.df, rename(.df, value_1=value_2, value_2=value_1)) )(.)) %>% 
  # filter(value_1 < 300, value_2 < 300) %>% 
  ggplot(aes(value_1, value_2, col=rel)) +
  # facet_grid(variable~rel, scales='free') +
  facet_wrap(~variable+rel, scales='free', labeller = labeller(.cols=label_value, .multi_line=FALSE)) +
  geom_abline(col='gray50') +
  geom_abline(intercept=c(-70, 70), col='gray50', lty='dashed') +
  geom_point(alpha=.25, size=.25) +
  expand_limits(x=0, y=0) +
  labs(x='induction lag cell 1 (min)', y='induction lag cell 2 (min)', col='relationship') +
  # scale_colour_manual(values=c('sisters'=brewer_cols[1], 'cousins2'=brewer_cols[3])) +
  guides(col='none') +
  theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1))


# filter(mypairs_switching, rel!='niece') %>% 
#   filter(switch_idx==1) %>% 
#   mutate(value_1=ifelse(value_1<240*60, value_1, Inf), value_2=ifelse(value_2<240*60, value_2, Inf)) %>% 
#   filter(is.finite(value_1), is.finite(value_2)) %>% 
#   group_by(condition, date, variable, rel) %>% 
#   summarise(r2=cor_sym(value_1, value_2, method="pearson")^2, n=n()) %>% 
#   (function(.df) 
#     ggplot(.df, aes(rel, r2)) +
#      facet_grid(variable~condition+date, labeller=as_labeller(rename_conds)) +
#      geom_bar(aes(fill=rel), stat='identity', show.legend=FALSE) +
#      geom_text(aes(y=0.99, label=n), hjust="middle", vjust="top") +
#      expand_limits(y=1) + labs(x='relationship', y='squared pearson correlation r2') +
#      theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1))
#   )

```


