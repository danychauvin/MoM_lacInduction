---
title: "Growth in constant environments"
author: Thomas Julou
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

## Growth in constant environments

```{r}
myframes <- myframes %>% 
  # group_by(date, pos, gl, id) %>% 
  partition(date, pos, gl, id, cluster=mycluster) %>%
  do((function(.df){
    .n <- dim(.df)[1]
    .cell_cycle <- NA
    if (!any(.df$discard_start) && unique(.df$end_type)=='div')
      .cell_cycle <- ((1:.n)-.5) / .n
    .logl <- NA
    if (unique(.df$condition) %in% c('glucose', 'lactose', 'lactose_lowillum')  &&  .n > 4) {
      .mod_ll_t <- lm( log(length_um)~time_sec, .df)  # use lm() for predict with se
      .pred_ll <- predict(.mod_ll_t, se.fit=TRUE)
      .logl <- .pred_ll$fit
    }
    mutate(.df, cell_cycle=.cell_cycle, length_predict=exp(.logl),
          gfp_deriv=(gfp_nb-lag(gfp_nb))/(time_sec-lag(time_sec)))
  })(.)) %>% 
  collect()

```


Let's compute stats over the cell cycle for each cell.

```{r}
mycells <- filter(myframes, condition %in% c('glucose', 'lactose', 'lactose_lowillum'), !discard_top) %>%
  filter(!(date=='20160427' & time_sec>7e4)) %>%  # remove dilution step at the end of expt
  # group_by(condition, date, pos, gl, id, cell, parent_id, genealogy) %>%
  partition(condition, date, pos, gl, id, cell, parent_id, genealogy, cluster=mycluster) %>%
  filter(!any(discard_start), end_type=='div') %>% # full cell cycles only
  filter(n()>4) %>% # at least 4 time points
  do((function(.df) {
    # browser()
    
    .mod_ll_t <- lm( log(length_um)~time_sec, .df)  # use fastLm() for predict
    # .mod_ll_t <- fastLmPure( cbind(1, .df$time_sec), log(.df$length_um) )
    .mod_lg_t <- fastLmPure( cbind(1, .df$time_sec), log(.df$gfp_nb) )
    .mod_l_t <- fastLmPure( cbind(1, .df$time_sec), .df$length_um )
    .mod_g_t <- fastLmPure( cbind(1, .df$time_sec), .df$gfp_nb )
    .mod_g_l <- fastLmPure( cbind(1, .df$length_um), .df$gfp_nb )

    .time_birth <- first(.df$time_sec)
    .time_div <- last(.df$time_sec)
    .logl <- predict(.mod_ll_t, se.fit=TRUE)
    data.frame(npoints=.mod_ll_t$df.residual+1,
               time_birth=.time_birth, time_div=.time_div, 
               cell_num_from_top=mean(.df$cell_num_in_lane),
               cell_num_from_bottom=mean(.df$total_cell_in_lane-.df$cell_num_in_lane), 
               loglength_start=first(.logl$fit), loglength_startse=first(.logl$se.fit), 
               loglength_end=last(.logl$fit), loglength_endse=last(.logl$se.fit), 
               logl_time_slope=.mod_ll_t$coefficients[2], logl_time_slopesd=summary(.mod_ll_t)$coefficients[2,2], 
               # logl_time_slope=.mod_ll_t$coefficients[2], logl_time_slopesd=.mod_ll_t$stderr[2], 
               logl_time_r2=cor(.df$time_sec, log(.df$length_um))^2,
               logg_time_slope=.mod_lg_t$coefficients[2], logg_time_slopesd=.mod_lg_t$stderr[2], 
               logg_time_r2=cor(.df$time_sec, log(.df$gfp_nb))^2,
               l_time_slope=.mod_l_t$coefficients[2], l_time_slopesd=.mod_l_t$stderr[2], 
               l_time_r2=cor(.df$time_sec, .df$length_um)^2,
               g_first=first(.df$gfp_nb), g_last=last(.df$gfp_nb),
               g_time_slope=.mod_g_t$coefficients[2], g_time_slopesd=.mod_g_t$stderr[2], 
               g_time_r2=cor(.df$time_sec, .df$gfp_nb)^2,
               g_l_slope=.mod_g_l$coefficients[2], g_l_slopesd=.mod_g_l$stderr[2], 
               g_l_r2=cor(.df$length_um, log(.df$gfp_nb))^2)
  })(.) ) %>% 
  collect() %>% 
  arrange(condition, date, pos, gl, id) %>% 
  mutate(gl_id=gsub('\\.[0-9]+$', '', cell))


```

Let's compute instantaneous rates:

```{r} 
rate_width <- 6 # number of frames used for fitting
rate_hw <- round(rate_width/2) * dt * 60

myrates <- semi_join(myframes, mycells, by='cell') %>%  # keep only full cells in constant conditions
  # loop on all cells
  # group_by(condition, date, pos, gl, id, cell) %>%
  partition(condition, date, pos, gl, id, cell,
            cluster=mycluster %>% cluster_assign_obj(dt) %>% cluster_assign_obj(rate_hw) %>%
              cluster_assign_func(get_parent_cid) %>% cluster_assign_func(get_daughters_cid)) %>%
  do( (function(.dfc){
    .dfc %>% 
      group_by(time_sec) %>% 
      do((function(.p) {
        # browser()
        .df <- filter(.dfc, between(time_sec, .p[['time_sec']]-rate_hw, .p[['time_sec']]+rate_hw))
        .mod_ll <- fastLmPure( cbind(1, .df$time_sec), log(.df$length_um) )
        .mod_g <- fastLmPure( cbind(1, .df$time_sec), .df$gfp_nb )
        .mod_g_l <- fastLmPure( cbind(1, .df$length_um), .df$gfp_nb )
        data.frame(irate_npoints=.mod_ll$df.residual+1,
                   islope_ll_time=.mod_ll$coefficients[2], islopesd_ll_time=.mod_ll$stderr[2],
                   ir2_ll_time=corPearson(.df$time_sec, log(.df$length_um))^2,
                   ir2_l_time=corPearson(.df$time_sec, .df$length_um)^2,
                   islope_g_time=.mod_g$coefficients[2], islopesd_g_time=.mod_g$stderr[2],
                   ir2_g_time=corPearson(.df$time_sec, .df$gfp_nb)^2,
                   ir2_lg_time=corPearson(.df$time_sec, log(.df$gfp_nb))^2,
                   islope_g_l=.mod_g_l$coefficients[2], islopesd_g_l=.mod_g_l$stderr[2],
                   ir2_g_l=corPearson(.df$length_um, .df$gfp_nb)^2)
      })(.) )
  })(.) ) %>% 
  collect()

myrates <- myrates %>% 
  left_join(myframes %>% select(gl_id, cell, genealogy, start_time, end_time) %>% distinct) %>% 
  left_join(myframes %>% select(cell, time_sec, cell_num_in_lane, total_cell_in_lane, length_um, gfp_nb,
                                length_predict, gfp_deriv))

```


### Cell elongation dynamics over the experiment

Print an example of what cell traces look like and r2 CDF to show that elongation is more exponential than linear:

```{r}
ggplot(filter(myframes, !discard_start, !discard_top, condition=='glucose', end_type=='div', start_time>=2*3600) %>% ungroup %>%  filter(cell %in% cell[c(1, 100, 30, 300, 400)]),
       aes((time_sec-start_time)/60, length_um, col=cell)) +
  stat_smooth(method='lm', se=FALSE) +
  geom_path(alpha=0.8, size=1) +
  scale_colour_periodic_brewer(guide='none') +
  scale_x_continuous(breaks=seq(0, 80, 40)) +
  scale_y_continuous(trans='log2', breaks=2:4) +
  expand_limits(y=4) +
  labs(x='time after division (min)', y='length (µm)')
# ggsave('plots/asc_loglength_time.pdf', width=2.5, height=3)

ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')) ) +
  stat_ecdf(aes(logl_time_r2, col=condition, lty='exponential')) +
  stat_ecdf(aes(l_time_r2, col=condition, lty='linear')) +
  labs(x='Pearson correlation r2', y='cumulative probability', lty='fit') +
  xlim(0.94, 1) +
  theme(legend.justification=c(0, 1), legend.position=c(0, 1))
# ggsave('plots/asc_loglength_time_r2ecdf.pdf', width=2.5, height=3.5)


```


Neither the cell length nor the doubling time increases during experiments in constant conditions, indicating limited photodamage and physiological aging.

```{r}
myframes %>% filter(condition %in% c('glucose', 'lactose')) %>% 
         filter(!discard_start, !discard_top, end_type=='div', start_time>=2*3600) %>%
         sample_frac(.1, replace=FALSE) %>% 
  ggplot(aes(time_sec - 2*3600, length_um, col=condition)) +
  facet_grid(condition~.) +
  # stat_density2d()
  geom_point(alpha=.1) +
  scale_x_hours()
# geom_point(aes(time_sec, length_um), alpha=0.1)

ggplot(filter(myframes, condition %in% c('glucose', 'lactose'), !discard_top), 
       aes(time_sec, length_um, col=condition)) +
  geom_smooth()

```



```{r}
# table(mycells %>% filter(condition %in% c('glucose', 'lactose'))$Rsize_vs_time^2>.95)
mycells %>% filter(condition %in% c('glucose', 'lactose'), logl_time_r2>.95) %>% 
  ( function(.df)
    ggplot(.df, aes(time_div - 2*3600, log(2)/logl_time_slope / 60, col=condition)) +
      geom_point(alpha=0.2, size=1) +
      # stat_smooth(method='loess', span=.7, se=FALSE, size=1) +
      stat_smooth(method='lm', size=1,
                  data=filter(.df, time_birth > 5*3600)) +
      scale_x_hours(6, name='time at division (h)') +
      labs(y='doubling time (min)') +
      expand_limits(x=c(0, 24*3600), y=0) +
      theme(legend.justification=c(0, 1), legend.position=c(0, 1)) )
# ggsave('plots/asc_dt_divtime.pdf', width=6, height=3)

```


Let's look at the distribution of doubling times.

```{r}
ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')), 
       # %>% filter(Rsize_vs_time^2>.98),
       aes(log(2)/logl_time_slope / 60)) +
  stat_bin(aes(y=..density.., fill=condition), geom='bar', position='identity', col='transparent', alpha=.2) + 
  geom_step_hist(aes(y=..density.., col=condition), position='identity') +
    # stat_ecdf() +
  xlim(0, 300) +
  labs(x='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))
# ggsave('plots/asc_dt.pdf', width=3.5, height=3.5)

```

NB: the decrease is the quality of the elongation fit is only moderate for cells with long doubling time (for dt>100, r2 <= 5% for r2 propto dt)
 
```{r eval=FALSE}
ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')),
       aes(log(2)/logl_time_slope / 60, logl_time_r2, col=condition)) +
  facet_wrap(~condition) +
  geom_point(alpha=.2) +
  geom_smooth(method='lm') +
  # stat_density2d() +
  labs(x='doubling time (min)') +
  xlim(50, 200) + ylim(0.95, 1)

mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  group_by(condition) %>% 
  mutate(dt=log(2)/logl_time_slope / 60 ) %>% 
  filter(dt > 100) %>% 
  do((function(.df){
    .mod <- fastLmPure( cbind(1, .df$dt), .df$logl_time_r2 )
    data.frame(slope=.mod$coefficients[2],
            r2=cor(.df$dt, .df$logl_time_r2)^2)
    })(.)) %>% kable

```


Let's check that cells with long doubling time are not filamentous: the slowest 10% in each condition have a similar length but they tend to be slightly longer. 

```{r}
l_end <- select(mycells, date, pos, gl, id, time_sec=time_div) %>%
  left_join(select(myframes, date, pos, gl, id, time_sec, length_um)) %>%
  rename(length_um_end=length_um)
mycells <- left_join(mycells, l_end %>% select(-time_sec)) %>% ungroup

mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  group_by(condition) %>% 
  mutate(dt=log(2)/logl_time_slope / 60,
         is_long_dt= dt>quantile(dt, 0.9)) %>% 
  ( function(.df)
    ggplot(.df, aes(length_um_end, ..density.., col=condition)) +
      facet_wrap(~condition) +
      geom_step_hist(aes(linetype='all'), position='identity') +
      geom_step_hist(aes(linetype='long dt (10%)'), position='identity', 
                     data=filter(.df, is_long_dt)) +
      labs(linetype='subset') )

```

```{r eval=FALSE}
ggplot(mycells %>% filter(condition %in% c('glucose', 'lactose')), 
       aes(length_um_end, log(2)/logl_time_slope / 60, col=condition)) +
  facet_wrap(~condition) +
  geom_point(alpha=0.2)

mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  group_by(condition) %>% 
  mutate(dt=log(2)/logl_time_slope / 60,
         is_long_dt= dt>quantile(dt, 0.9)) %>% 
  filter(is_long_dt) %>% 
  do((function(.df){
    .mod <- fastLmPure( cbind(1, .df$length_um_end), .df$dt )
    data.frame(slope=.mod$coefficients[2],
            r2=cor(.df$length_um_end, .df$dt)^2)
    })(.)) %>% kable

```


### Residuals over the cell cycle

```{r}
ggplot(myframes %>% filter(!discard_top, !discard_start, condition %in% c('glucose', 'lactose')),
       aes((time_sec-start_time)/60, length_um-length_predict)) +
  facet_wrap(~condition) +
  geom_hline(yintercept=0, col='red') +
  # geom_path(aes(col=interaction(date, pos), group=cell), size=.5, alpha=.1) +
  stat_summary(fun.data=mean_sdl, geom="pointrange") +
  xlim(0, 200)

```


### Autocorrelation of elongation

```{r}
ggplot(myrates, aes(x=(time_sec-start_time)/60)) +
  # geom_line(aes(y=islope_ll_time, col=condition, group=cell), alpha=0.1) + 
  stat_summary(aes(y=islope_ll_time, col=condition), fun.data=mean_cl_normal, geom="pointrange") +
  # stat_summary(aes(y=islope_ll_time, col=condition), fun.y=mean, geom="point") +
  xlim(0, 200) +
  expand_limits(y=0)

ggplot(myrates, aes(x=mycut((time_sec-start_time)/(end_time-start_time), seq(0,1,.03)))) +
  # geom_line(aes(y=islope_ll_time, col=condition, group=cell), alpha=0.1) +
  stat_summary(aes(y=islope_ll_time, col=condition), fun.data=mean_cl_normal, geom="pointrange") +
  expand_limits(y=0) +
  labs(x='cell cycle')

```


```{r}
myrates %>% filter(condition %in% c('glucose', 'lactose'),
                   cell_num_in_lane==total_cell_in_lane) %>% 
  ggplot(aes(time_sec, islope_ll_time)) +
  geom_line(aes(col=condition, group=gl_id), alpha=.25) +
  # stat_summary(aes(col=condition), fun.y=mean, geom="point") +
  stat_smooth(aes(col=condition), method='lm') +
  geom_hline(yintercept=1e-4, lty='dotted')

myrates %>% filter(condition %in% c('glucose', 'lactose'),
                   cell_num_in_lane==total_cell_in_lane) %>% 
  group_by(condition, date, pos, gl) %>% 
  do((function(.df){
    # browser()
    .acf <- acf(.df$islope_ll_time, lag.max=100, plot=FALSE)
    data.frame(lag=.acf$lag*dt, acf=.acf$acf)
  })(.)) %>% 
  ggplot(aes(lag, acf)) +
  facet_grid(.~condition) +
  geom_line(aes(col=condition, group=interaction(date, pos, gl)), alpha=.2) +
  stat_summary(aes(col=condition), fun.data=mean_cl_normal, geom="pointrange")

```


Let's look at the corresponding doubling time distribution:

```{r}
mycells %>% 
  semi_join(filter(myrates, cell_num_in_lane==total_cell_in_lane), by='cell') %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  ggplot(aes(log(2)/logl_time_slope / 60)) +
  stat_bin(aes(y=..density.., fill=condition), binwidth=5,
           geom='bar', position='identity', col='transparent', alpha=.2) + 
  geom_step_hist(aes(y=..density.., col=condition), binwidth=5, position='identity') +
  # stat_ecdf() +
  # xlim(0, 300) +
  labs(x='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))

mycells %>% 
  semi_join(filter(myrates, cell_num_in_lane==total_cell_in_lane), by='cell') %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  ggplot(aes(log(2)/logl_time_slope / 60)) +
  stat_ecdf(aes(y=1-..y.., col=condition)) + 
  # xlim(0, 300) +
  scale_y_log10() +
  labs(x='doubling time (min)', y='reverse cumulative probability') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))

mycells %>% 
  semi_join(filter(myrates, cell_num_in_lane==total_cell_in_lane), by='cell') %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  ggplot(aes(time_div/3600, log(2)/logl_time_slope / 60, col=condition)) +
  geom_point() +
  stat_smooth(method='lm') +
  labs(y='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))

```

NB: the doubling time distribution depends on the bottom rank...

```{r}
mycells %>% 
  filter(condition %in% c('glucose', 'lactose')) %>% 
  mutate(cell_num_from_bottom=round(cell_num_from_bottom)) %>% 
  filter(cell_num_from_bottom<6) %>% 
  ggplot(aes(time_div/3600, log(2)/logl_time_slope / 60, col=condition)) +
  facet_grid(.~cell_num_from_bottom) +
  geom_point(alpha=.1) +
  stat_smooth(method='lm') +
  coord_cartesian(ylim=c(0, 200)) +
  labs(y='doubling time (min)') +
  theme(legend.justification=c(1, 1), legend.position=c(1, 1))


```


### Growth rate inheritance 

Is there a genealogical signal on growth rate in constant environment?
NB: Growth rate is show in doubling time units…

```{r}
mypairs_constant <- mycells %>% filter(condition %in% c('glucose', 'lactose')) %>% 
  # group_by(gl_id) %>% 
  partition(gl_id, cluster=mycluster %>% cluster_assign_func(genealogy_relationship) %>% cluster_assign_func(genealogy_ontology)) %>% 
  do((function(.df) {
    # browser()
    if (dim(.df)[1]<2) 
      return(data.frame())
    return( combn(.df$genealogy, 2, simplify=FALSE) %>% 
      lapply(function(.x) as.data.frame(genealogy_relationship(.x), stringsAsFactors=FALSE)) %>% 
      do.call(rbind, .) )
  })(.)) %>% 
  collect() %>% 
  # mutate(rel=factor(rel, levels=c("sisters", "cousins1", "cousins2", "niece"))) %>% 
  left_join(mycells %>% ungroup %>% 
              setNames(., paste(names(.), "1", sep="_")) %>% rename(gl_id=gl_id_1) ) %>% 
  left_join(mycells %>% ungroup %>% 
              setNames(., paste(names(.), "2", sep="_")) %>% rename(gl_id=gl_id_2) ) %>% 
  # compute "ordered" doubling times
  group_by(div_min, div_max) %>% 
  mutate(
    dt_upstream = ifelse(div_1<div_2, log(2)/logl_time_slope_1 / 60, log(2)/logl_time_slope_2 / 60),
    dt_downstream = ifelse(div_1<div_2, log(2)/logl_time_slope_2 / 60, log(2)/logl_time_slope_1 / 60),
    dt_upstream2 = mycut(dt_upstream, seq(0, 1000, 10)))


ggplot(filter(mypairs_constant, TRUE), aes(log(2)/logl_time_slope_1 / 60, log(2)/logl_time_slope_2 / 60, col=factor(rel))) +
  # facet_wrap(~condition_1) +
  geom_point(alpha=.5, size=.5) +
  expand_limits(x=0, y=0)


filter(mypairs_constant, TRUE) %>% 
  group_by(div_min, div_max) %>% 
  # group_by(condition_1, div_min, div_max) %>% 
  summarise(r2=cor(log(2)/logl_time_slope_1 / 60,  log(2)/logl_time_slope_2 / 60, use="complete.obs", method="pearson")^2, n=n()) %>% 
  mutate(rel=(Vectorize(genealogy_ontology))(div_min, div_max)) %>% 
  (function(.df) ggplot(.df, aes(div_min, div_max)) +
     # facet_wrap(~condition_1) +
     geom_tile(aes(fill=r2), stat='identity', show.legend=FALSE) +
     geom_text(aes(label=sprintf("%s\nr2 = %.3f", rel, r2))) +
     geom_text(aes(y=div_max-.4, label=sprintf("(n = %d)", n))) +
     scale_fill_gradient(high='red', low='lightblue') +
     scale_x_continuous(breaks=0:10, expand=c(0,0)) + scale_y_continuous(trans="reverse", breaks=0:10, expand=c(0,0)) +
     expand_limits(fill=0) + coord_fixed() +
     labs(x='divs since common ancestor (cell 1)', y='div since common ancestor (cell 2)')
  )

```

Let's look at the corresponding distributions:

```{r}
ggplot(mypairs_constant, aes(dt_upstream, dt_downstream)) +
  facet_grid(div_max~div_min) +
  geom_point(size=.2, alpha=.1) +
  # geom_smooth(col=brewer_cols[1]) +
  stat_summary(aes(x=dt_upstream2), fun.data=mean_sdl, geom="pointrange", col=brewer_cols[1]) +
  xlim(0, 200) + ylim(0, 200)

```


The weaker correlation between mothers/daughters than between sisters suggests a finer analysis with 2 estimates per cell. Given that the instantaneous elongation rate is rather constant over the cell cycle (but when adjacent points before/after division are taken into account), I use one estimation at 25% of the cell cycle and another at 75% (outside of the +-5points fitting window for cell cycles longer than 60min).

Cells are selected according to the following scheme:

- pick all pairs of sisters with entire cell cycles
- keep only if their mother also has an entire cell cycle
- for these 3 cells, compute all combination of points involving 2 different cells
- at the end, list all cells used in the table and add their internal points
(estimate their growth rate using either instantaneour estimate based on 10 points at 25% and 75% of the cell cycle; or using an exponential fit over 1/2 the cell cycle)

```{r}
mysubpairs_constant <- 
  (function() {
    # browser()
    # # select rates of all cells
    # myrates_25_75 <- myrates %>% filter(condition %in% c('glucose', 'lactose')) %>% 
    #   mutate(cell_cycle=(time_sec-start_time)/(end_time-start_time)) %>% 
    #   group_by(cell) %>% slice(c(which.min((cell_cycle-0.25)^2), which.min((cell_cycle-0.75)^2))) %>% 
    #   group_by(cell) %>% mutate(cc=c(1, 2)) %>% 
    #   select(cell, gl_id, cell, genealogy, cc, irate=islope_ll_time) %>% ungroup
    
    myrates_halfcc <- myframes %>% 
      # keep only frames of cells seen during their entire cell cycle
      semi_join(filter(mycells, condition %in% c('glucose', 'lactose'))) %>% 
      ungroup %>% 
      mutate(cell_cycle=(time_sec-start_time)/(end_time-start_time),
             cc=ifelse(cell_cycle<0.5, 1, 2)) %>% 
      group_by(cell, cc,  gl_id, genealogy) %>% 
      do((function(.df) {
        .mod_ll_t <- fastLmPure( cbind(1, .df$time_sec), log(.df$length_um) )
        data.frame(irate=.mod_ll_t$coefficients[2])
      })(.) ) %>% 
      # collect() %>% 
      ungroup
    
    
    # myrates_25_75 %>% mutate(cc=paste0('ir', cc)) %>% spread(cc, irate) %>%
    # ggplot(aes(ir1, ir2))+geom_point(alpha=.1) + geom_abline(col='red') + stat_smooth(method='lm')
    
    
    .rel_table <- combn(1:6, 2) %>% t %>% as.data.frame %>% slice(-c(1, 10, 15)) %>% 
      setNames(c('row1', 'row2')) %>% 
      mutate(rel_d=c("d10", "d15", "d10", "d15", "d5", "d10", "d5", "d10", "s5", "s10", "s10", "s15"),
             rel=substr(rel_d, 1, 1) %>% sub('d', 'daughter', .) %>% sub('s', 'sisters', .),
             dist=as.numeric(substring(rel_d, 2)))
    # in the following, .rel_table assumes the following row order in my rates:
    #             ————— —————
    #  1      2  /  3     4
    # ————— —————
    #            \  5     6
    #             ————— —————
    
    mypairs_constant %>% filter(condition_1 %in% c('glucose', 'lactose'), rel=='sisters') %>% 
      group_by(gl_id, ancestor) %>% 
      # partition(gl_id, ancestor, cluster=mycluster %>% ) %>% 
      do( (function(.df){
        # extract data from cell pairs (only if mother has entire cell cycle)
        # browser()
        .rates <- filter(myrates_halfcc, gl_id==.df$gl_id, genealogy %in% c(.df$ancestor, .df$genealogy_1, .df$genealogy_2)) %>% 
          arrange(genealogy, cc) # mind the rows order!
        if (dim(.rates)[1] < 6) return(data.frame())
        
        cbind(.rel_table %>% select(rel, dist),
              .rates %>% select(cell, cc, irate) %>% setNames(paste0(colnames(.), '_1')) %>% slice(.rel_table$row1),
              .rates %>% select(cell, cc, irate) %>% setNames(paste0(colnames(.), '_2')) %>% slice(.rel_table$row2))
      })(.) ) %>% 
      select(-ancestor) %>% 
      # add data from within cells
      (function(.df){
        .cells <- .df %>% filter(rel=='sisters') %>% select(cell_1, cell_2) %>% unlist %>% unique # xxx this is shorter than 2 x nb of pairs !!
        bind_rows(.df, 
                  filter(myrates_halfcc, cell %in% .cells) %>% 
                    mutate(cc=paste0('irate_', cc)) %>% spread(cc, irate) %>% 
                    mutate(rel='cell', dist=5, cell_1=cell, cell_2=cell, cc_1=1, cc_2=2) %>% 
                    select(-genealogy, -cell) )
      }) %>% 
      mutate(dist=dist/10)
  })()

mysubpairs_constant %>% 
  group_by(rel, dist) %>% 
  summarise(r2=cor(irate_1, irate_2)^2) %>% #, n=n()
  spread(rel, r2)

```

